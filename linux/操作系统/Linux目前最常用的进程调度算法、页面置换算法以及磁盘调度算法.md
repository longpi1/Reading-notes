## Linux目前最常用的进程调度算法、页面置换算法以及磁盘调度算法

操作系统是计算机硬件与应用软件之间的桥梁，其核心任务之一就是有效地管理系统资源。在Linux系统中，为了实现高效、公平和响应迅速的资源分配，采用了多种精妙的调度和置换算法。本文将深入探讨Linux目前最常用的进程调度算法、页面置换算法以及磁盘调度算法。

### 1. 进程调度算法：完全公平调度器 (CFS)

Linux的进程调度器在不断演进，但自内核版本2.6.23（2007年）以来，**完全公平调度器 (CFS - Completely Fair Scheduler)** 已经成为非实时进程（即普通用户进程）的默认和最主要的调度算法。

**核心思想：** CFS的目标是实现“理想的、完美的、公平的多任务处理”。它不再像以前那样使用固定的时间片，而是为每个进程维护一个**虚拟运行时 (vruntime)**。CFS试图让每个进程的`vruntime`尽可能地保持一致。

**工作原理：**

1. **虚拟运行时 (vruntime)：** 每个可运行进程都有一个`vruntime`值，表示该进程“已经运行了多久”的虚拟时间。这个虚拟时间会根据进程的优先级（`nice`值）进行加权：优先级越高的进程，其`vruntime`增长得越慢（意味着它看起来“运行得少”，因此会被调度器优先选择）。
2. **红黑树 (Red-Black Tree)：** 所有可运行进程都被组织在一棵红黑树中，以`vruntime`作为键值。红黑树的特性确保了最左边的叶子节点（即`vruntime`最小的进程）总是可以被高效地找到。
3. **选择策略：** 调度器总是选择红黑树中最左边的进程（即`vruntime`最小的进程）来运行。这意味着“运行最少”的进程将获得CPU时间。
4. **时间片：** 虽然没有固定时间片，但CFS仍然有一个概念叫“调度周期 (scheduling period)”。在这个周期内，所有可运行的进程都会获得一定比例的CPU时间，这个比例根据它们的`nice`值进行分配。进程的实际运行时间取决于这个周期以及它在红黑树中的位置。

**优势：**

- **高度公平：** 确保每个进程都能获得“公平”的CPU时间份额，尤其是在多核处理器上。
- **低延迟：** 适用于交互式任务，因为“运行最少”的进程会被优先调度，提供了良好的响应性。
- **可伸缩性：** 红黑树操作的对数复杂度使得它在大规模进程数量下也能保持高效。
- **简单且优雅：** 相对于之前的O(1)调度器，CFS的设计哲学更为简洁。

**特殊情况：** 除了CFS处理的普通进程外，Linux还支持针对实时（Real-Time）应用的调度策略，例如`SCHED_FIFO`（先进先出）和`SCHED_RR`（时间片轮转），这些策略具有更高的优先级，且不受CFS公平性原则的约束。

### 2. 页面置换算法：近似LRU (Two-List LRU Approximation)

Linux的内存管理是复杂的，其中页面置换是关键一环。由于纯粹的LRU（最近最少使用）算法需要精确记录每个页面的访问时间戳，这会带来巨大的开销，因此Linux并未使用严格的LRU，而是采用了一种**近似LRU的变种**，通常被称为**两阶段LRU (Two-List LRU Approximation)** 或基于活跃/非活跃列表的LRU。

**核心思想：** 通过维护两个页面列表——活跃 (Active) 列表和非活跃 (Inactive) 列表——来近似模拟LRU行为，从而在性能和开销之间取得平衡。

**工作原理：**

1. **活跃 (Active) 列表：** 存放最近被频繁访问的页面。这些页面被认为是“热”的，应该留在内存中。
2. **非活跃 (Inactive) 列表：** 存放最近较少被访问或已有一段时间未被访问的页面。这些页面被认为是“冷”的，是页面置换的首选目标。

**页面转换机制：**

- **新页面加载：** 当一个页面首次从磁盘加载到内存时，它通常被放到非活跃列表的头部。
- 页面访问：
  - 如果一个页面在活跃列表中被访问，它会保持在活跃列表中，并可能被移动到列表的更热端（虽然不严格）。
  - 如果一个页面在非活跃列表中被访问，它会被重新标记为活跃，并移动到活跃列表的头部。这模拟了LRU中“最近使用”的特性。
- 页面老化：
  - 当内存压力增大，需要回收页面时，系统会从活跃列表的尾部将页面移动到非活跃列表的头部。这些页面在活跃列表中停留了一段时间，如果它们在移动后的一段时间内没有再次被访问，那么它们就真的变“冷”了。
  - 页面回收优先从非活跃列表的尾部开始。如果一个页面在非活跃列表中停留了足够长的时间（并且没有被再次访问导致移回活跃列表），那么它将被选中进行置换（写回磁盘并释放内存）。

**优势：**

- **性能/开销平衡：** 避免了维护精确LRU所需的昂贵操作。
- **有效近似：** 能够相对准确地识别出“最近最少使用”的页面，减少了不必要的页面换入/换出。
- **对内存压力的响应：** 在内存紧张时，能有效地回收不常用的页面。

### 3. 磁盘调度算法：MQ-DEADLINE / BFQ / NOOP (blk-mq框架下)

磁盘调度算法在Linux中发展迅速，特别是随着SSD（固态硬盘）和NVMe（非易失性内存高速）等高速存储设备的普及。传统的机械硬盘（HDD）的调度算法需要考虑寻道时间，而SSD/NVMe的延迟主要在于其内部控制器和PCIe总线带宽。

自Linux内核4.x系列，特别是5.x及以上版本，Linux引入了**多队列I/O调度器（`blk-mq`）**框架，以更好地利用多核CPU和高速存储设备的并行能力。在这个新框架下，默认和最常用的调度器选择发生了变化。

**`blk-mq`框架：**

- `blk-mq`为每个CPU核心或每个I/O队列维护独立的提交队列，从而避免了传统单队列调度器在多核环境下的锁竞争，显著提升了高并发I/O性能。
- 大多数现代的块设备驱动（如NVMe驱动）都直接使用`blk-mq`。

**`blk-mq`框架下的主流调度器：**

1. **`mq-deadline` (多队列版本Deadline)**
   - **地位：** 在许多现代Linux发行版中，对于块设备（尤其是NVMe SSD），`mq-deadline`是`blk-mq`框架下的默认调度器。
   - **核心思想：** 保证读写请求的延迟。它为读请求和写请求维护单独的FIFO队列，并设置了过期时间（deadline）。
   - **工作原理：** 当调度器选择下一个请求时，它会优先检查是否有即将过期的请求，特别是读请求（因为读请求通常对延迟更敏感）。在没有过期请求的情况下，它会倾向于处理同类请求以减少寻道（对于HDD）或批处理（对于SSD）开销。
   - **适用场景：** 对I/O延迟敏感的场景，如数据库服务器、虚拟化平台。
2. **`BFQ` (Budget Fair Queueing)**
   - **地位：** 在桌面用户和交互式工作负载中非常受欢迎，尤其是在使用旋转磁盘（HDD）或需要极佳响应性的SSD上。一些发行版（如Fedora）曾将其作为默认。
   - **核心思想：** 提供卓越的公平性和低延迟。它为每个进程分配一个“预算”，确保每个进程在一定时间内都能获得I/O带宽，并优先处理交互式应用的请求。
   - **工作原理：** BFQ能识别同步和异步I/O，并为它们提供不同的调度策略。它通过合并请求和防止饥饿来优化性能，并且在混合I/O场景下表现出色。
   - **适用场景：** 桌面系统、需要高响应性且有大量并发I/O操作的场景。
3. **`noop` (No Operation)**
   - **地位：** 对于那些内部已经有非常高效队列管理机制的设备（如高端的NVMe SSD控制器、硬件RAID卡、或通过`dm-multipath`管理的多路径设备），`noop`是最佳选择。
   - **核心思想：** 尽可能减少内核层面的干预。它只是简单地将I/O请求按FIFO顺序传递给硬件，不进行任何排序或合并。
   - **工作原理：** 假设底层硬件已经非常智能，能够自行优化I/O请求，内核的额外调度只会增加延迟。
   - **适用场景：** 高性能NVMe SSD、硬件RAID、虚拟化环境中的后端存储等。

**历史调度器（在`blk-mq`之前或特定场景下）：**

- **`CFQ` (Completely Fair Queueing)：** 曾是机械硬盘的默认调度器。它尝试为所有进程公平分配磁盘带宽，适用于多用户、多应用场景。但在SSD上表现不佳，已被`blk-mq`框架下的调度器取代。
- **`deadline`：** 旧的单队列版本的`mq-deadline`，功能类似，但不支持多队列。

**如何查看和更改：** 你可以通过以下命令查看你的系统中某个磁盘当前使用的I/O调度器：

```
cat /sys/block/sdX/queue/scheduler
```

（将`sdX`替换为你的磁盘名称，如`sda`或`nvme0n1`）

输出会显示方括号中当前激活的调度器，例如 `[mq-deadline] noop none`。

你可以临时更改调度器：

```
echo "bfq" | sudo tee /sys/block/sdX/queue/scheduler
```

（这只会影响当前会话，重启后会恢复默认。要永久更改，需要编辑grub配置或创建udev规则。）

------

### 总结

Linux在进程、页面和磁盘调度方面都采用了先进且适应性强的算法：

- **进程调度：** **CFS (完全公平调度器)** 以其卓越的公平性和低延迟，确保了普通进程高效地共享CPU资源。
- **页面置换：** **近似LRU (两阶段LRU)** 通过维护活跃/非活跃列表，在不过度消耗系统资源的情况下，高效地管理内存页面。
- **磁盘调度：** 在现代Linux系统中，基于**`blk-mq`框架**的**`mq-deadline`**和**`BFQ`**是主流选择，而**`noop`**则适用于高性能、智能硬件。它们分别针对I/O延迟、公平响应性以及硬件自身优化进行了考量。

这些算法共同协作，构成了Linux高效、稳定且响应迅速的核心，使其能够胜任从嵌入式设备到超级计算机的各种复杂工作负载。同时，Linux内核社区持续不断地改进这些算法，以适应不断发展的硬件和用户需求。