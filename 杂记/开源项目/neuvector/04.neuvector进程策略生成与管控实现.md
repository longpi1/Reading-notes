# neuvector进程策略生成与管控实现

## 一、进程学习管控的实现方式

**策略学习实现：**

进程的学习与告警主要依据通过netlink socket实时获取进程启动和退出的事件:
1.创建netLink socket；
2.通过创建netlink的fd对进程的事件进行捕获与更新，主要是4种类型（exec，fork，exit，uidChange）；
3.学习模式下则对捕获的进程信息进行上报，形成对应的进程白名单，监视模式则对比当前白名单规则选择是否告警；

**策略管控实现：**

关于neuvector对进程的管控，虽然都是通过对比白名单策略，但是实际上可分为两条路径， **一种是基于fanotify实现的通过阻塞进程进行判断是否放行**，**另一种是基于syscall的形式（syscall.Kill(pid, syscall.SIGKILL)）直接杀死进程，但不会阻塞；**
两者之间的选择主要由capBlock属性决定；  



## 二、主要执行流程

保护模式下进程管控的主要流程如下图：

![image.png](https://s2.loli.net/2023/12/26/bNjquyCJv4c1lE3.png)



## 三、两种管控方式的使用场景以及优缺点（个人观点）：

| 实现方式                           | 使用场景                                       | 优点                                                         | 缺点                                                         |
| ---------------------------------- | ---------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| fanotify实现                       | 业务容器、除去syscall.Kill场景下的 其他容器pod | 基于阻塞的方式管控进程，可以有 效防止黑名单进程执行          | 当容器或者pod中存在大量进程运行 时，阻塞的方式可能会导致容器中 进程运行速度变低， 所以不适用主 机节点以及进程较多的系统容器； |
| syscall.Kill(pid, syscall.SIGKILL) | 更多操作syscall.Kill(pid, syscall.SIGKILL)     | 基于非阻塞的方式管控进程，不会 影响被管控容器或者pod的进程执行 速度； | 1.当进程执行速度很快或者Enforcer 通道通信过慢时，可能会来不及杀 死对应的黑名单进程； 2.当超过通道容量2048时，后续的 进程处理将被忽略 |

