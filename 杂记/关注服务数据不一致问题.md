一个百亿级关注链的关注系统，关注表和粉丝表做了拆分，如何保证两个表的一致性，以及关注数、粉丝数异步更新的问题，目前写逻辑只更新关注表，然后异步更新粉丝列表、关注数、粉丝数



场景——“**写关注表，异步更新粉丝表和计数**”——正是业界为了应对海量关注关系（如微博、Twitter）所采用的主流高性能策略。

这个策略的核心在于，它为了**提升核心操作（关注/取关）的性能和可用性**，牺牲了数据的**强一致性**，转而追求**最终一致性**。

下面，我将为你深入剖-析这个设计中的关键点：如何保证最终一致性，以及如何处理异步更新中可能出现的各种问题。

------

### 一、问题场景与核心矛盾

我们先明确一下当前的架构和你面临的核心问题：

- 架构：
  - **关注表 (Following Table/List)**：`following:<user_A_id>` -> `{user_B_id, user_C_id, ...}`
  - **粉丝表 (Follower Table/List)**：`follower:<user_B_id>` -> `{user_A_id, ...}`
  - **关注数/粉丝数 (Counts)**：存储在用户信息表或独立的计数服务中。
- 操作流程：
  1. **同步核心操作**：用户A点击关注B，**只**更新**关注表**，即在 `following:A` 中加入 `B`。这个操作必须成功且快速响应给用户。
  2. 异步后续操作：通过消息队列 (MQ) 发送一个事件，由后台消费者去完成：
     - 更新**粉丝表**：在 `follower:B` 中加入 `A`。
     - 更新A的**关注数**。
     - 更新B的**粉丝数**。
- **核心矛盾**：在同步操作成功后，到异步操作全部完成前，系统处于一个**中间状态（数据不一致）**。例如，A的关注列表里有B，但B的粉丝列表里还没有A。**如何保证这个不一致的窗口期尽可能短，并且最终数据一定会对齐？**

------

### 二、保证最终一致性的核心机制

要解决这个问题，我们需要一套健壮的、围绕消息队列的“**可靠消息最终一致性**”方案。

#### 1. 保证“消息一定能发出去”：事务消息 或 本地消息表

这是最关键的一步。如果同步写“关注表”成功了，但发送消息到 MQ 失败了，那么粉丝关系和计数就永远不会被更新，数据将永久不一致。

- **方案A：事务消息 (Transactional Message)**
  - 一些 MQ 产品（如 RocketMQ, Pulsar）原生支持事务消息。
  - 流程：
    1. **发送半消息 (Half Message)**：应用先向 MQ 发送一条“半消息”。这条消息对消费者不可见。
    2. **执行本地事务**：应用在本地数据库/缓存中执行“更新关注表”的操作。
    3. 确认/回滚消息：
       - 如果本地事务**成功**，则向 MQ 发送一个 `COMMIT`，MQ 将半消息标记为可投递，消费者可以消费。
       - 如果本地事务**失败**，则向 MQ 发送一个 `ROLLBACK`，MQ 会删除这条半消息。
  - **优点**：将消息发送和本地事务绑定，由 MQ 中间件保证原子性，对应用层透明。
- **方案B：本地消息表 (Local Message Table / Transactional Outbox Pattern)**
  - 这是一个更通用的方案，不依赖于特定的 MQ 功能。
  - 流程：
    1. **开启本地事务**：在**同一个数据库事务**中，执行两个操作：
       a. **更新关注表**。
       b. 向一个本地的 `message_outbox` 表中**插入一条消息记录**（状态：待发送）。
    2. **提交本地事务**：由于 a 和 b 在同一个事务中，它们保证了原子性。要么都成功，要么都失败。
    3. **独立的“中继”服务**：一个后台任务（或独立的服务）不断地轮询 `message_outbox` 表，将“待发送”的消息投递到真正的 MQ 中。
    4. **确认投递**：当 MQ 确认收到消息后，中继服务将 `message_outbox` 表中对应的记录状态更新为“已发送”或直接删除。
  - **优点**：与 MQ 解耦，适用于任何数据库和 MQ 组合。可靠性极高。

**通过上述任一方案，我们解决了第一个关键问题：只要关注操作成功，更新后续数据的“指令”就一定能可靠地进入消息队列。**

#### 2. 保证“消息一定能被成功消费”：消费者端的幂等性与重试

消息进入 MQ 后，消费者可能会因为各种原因（自身宕机、下游数据库抖动）消费失败。MQ 的可靠性机制（如 at-least-once）会进行重试，这就要求我们的消费逻辑必须是**幂等（Idempotent）**的。

- **幂等性**：对同一个消息处理一次和处理多次，结果应该完全相同。

- **如何实现幂等消费**：

  - **粉丝表更新**：向 Redis 的 **Set** 中添加粉丝ID (`SADD follower:B A`) 本身就是幂等的。多次执行 `SADD`，结果和执行一次是一样的。

  - 计数器更新

    ：简单的INCR/DECR 不是幂等的

    。如果重试，计数会加/减多次。

    - **解决方案1：带条件的更新**：消费时，先查询粉丝表，**只有当粉丝关系还不存在时，才执行 INCR 操作**。这需要将“查粉丝表”和“INCR计数”这两个操作包装成一个原子操作（例如，使用 Lua 脚本）。
    - **解决方案2：引入全局唯一消息ID**：每个消息都有一个唯一ID。消费者在处理消息前，先在一个持久化的存储（如 Redis Set 或数据库表 `processed_messages`）中检查该 `message_id` 是否已处理过。如果处理过，直接 ACK 并跳过；如果没有，则处理业务逻辑，并将 `message_id` 存入已处理集合中。

- **失败与重试**：

  - 对于可恢复的错误（如数据库瞬时抖动），消费者应该返回消费失败，让 MQ 自动重试。
  - 对于不可恢复的错误（如消息格式错误），或者重试多次后仍然失败的消息，应该将其投入一个**死信队列（Dead-Letter Queue, DLQ）**。
  - 需要有专门的监控和告警机制来关注死信队列，以便人工介入处理这些“疑难杂症”。

------

### 三、处理异步更新带来的问题

#### 1. 短暂的数据不一致

- **问题**：用户 A 关注 B 后，立即刷新 B 的粉丝列表，可能看不到自己。
- 解决方案：
  - **接受它**：对于大多数社交应用，秒级甚至分钟级的不一致是可以接受的。这是为了换取系统高性能和可用性所付出的合理代价。可以向用户展示“操作成功”的即时反馈，后台慢慢同步即可。
  - **前端优化**：在用户 A 的客户端，当他关注 B 成功后，可以**在前端本地“假装”B 的粉丝数已经+1**，并把自己显示在 B 的粉丝列表里。当用户刷新页面，重新从后端拉取真实数据时，这种“假象”就会被覆盖。这是一种常见的、提升用户体验的“障眼法”。

#### 2. 关注与取关的乱序问题

这是一个更复杂的问题。考虑以下场景：

1. T1 时刻：用户 A 关注 B。消息 `M_follow` 进入 MQ。
2. T2 时刻：用户 A 立即取消关注 B。消息 `M_unfollow` 进入 MQ。

由于网络延迟或 MQ 分区等原因，消费者可能**先消费了 `M_unfollow`，后消费了 `M_follow`**。

- 消费者处理 `M_unfollow`：尝试从粉丝列表删除 A（此时可能还不存在），并将粉丝数 -1。

- 消费者处理 `M_follow`：向粉丝列表添加 A，并将粉丝数 +1。

- **最终结果**：A 和 B 变成了关注状态，而用户的本意是取关。数据永久不一致！

- **解决方案**：

  - 引入版本号或时间戳

    ：在消息体中携带操作发生的时间戳。消费者在处理时，对比当前状态的版本/时间戳。只有当消息的版本/时间戳比当前状态更新时，才执行操作。

    - 例如，在 Redis 中用一个 Hash 来存储关系，`HSET following:A B <timestamp>`。
    - 消费者处理消息时，先获取当前存储的时间戳，只有当消息中的时间戳更新时，才执行操作。

  - **保证同一用户的消息有序**：利用 MQ 的特性，将**同一个用户**的所有操作消息，通过指定 `partition_key` (使用 `user_id`) 发送到**同一个分区**。Kafka/Pulsar 等 MQ 能保证单个分区内的消息是严格有序的。这样，`M_follow` 就一定会比 `M_unfollow` 先被消费。

### 四、架构总结

一个健壮的、支持最终一致性的异步关注系统架构如下：

```
+----------+      +------------------+      +-------------------+
|  Client  |----->|  API Gateway     |----->|  关注服务 (Go)    |
+----------+      +------------------+      +-------------------+
                                                  | 1. 同步操作
                                                  V
                                    +------------------------------+
                                    | 关注关系存储 (e.g., Redis Set) |  <-- 更新 following:user_A
                                    +------------------------------+
                                                  | 2. 可靠消息投递
                                                  V
+----------------------------------------------------------------------------------+
|                                  消息队列 (Pulsar/Kafka)                           |
|  - Topic: user_relations_topic                                                   |
|  - Message: {type:"FOLLOW", user_id:"A", target_id:"B", timestamp:123456}         |
+----------------------------------------------------------------------------------+
                                                  | 3. 异步消费
                                                  V
          +------------------------------------------------------------------+
          |                      粉丝关系消费者 (Go Consumer)                  |
          |                                                                  |
          | a. (幂等) 更新粉丝表: SADD follower:user_B user_A                   |
          | b. (幂等/原子) 更新关注数/粉丝数: (Lua or Check-then-Set)        |
          | c. 处理失败 -> 重试 / 死信队列                                     |
          +------------------------------------------------------------------+
```

**结论**：
通过**事务消息/本地消息表**保证了“指令”的可靠发出，通过**消费者幂等性、重试、死信队列**保证了“指令”的可靠执行，通过**时间戳/有序消息**解决了乱序问题。这套组合拳，就是在分布式环境下，用**最终一致性**来解决海量数据关注系统一致性问题的标准答案。