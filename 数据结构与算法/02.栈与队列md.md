# æ•°æ®ç»“æ„â€”æ ˆä¸é˜Ÿåˆ—

> ç›¸å…³æ•°æ®ç»“æ„å®ç°ç”¨goè¯­è¨€å®ç°
>
> ç›¸å…³ä»£ç åšé¢˜åˆé›†ï¼šhttps://github.com/longpi1/algorithm-pattern

go é€šè¿‡åˆ‡ç‰‡æ¨¡æ‹Ÿæ ˆå’Œé˜Ÿåˆ—

## æ ˆ

```go
åˆ‡ç‰‡æ¨¡æ‹Ÿæ ˆ
// åˆ›å»ºæ ˆ
stack:=make([]int,0)
// pushå‹å…¥
stack=append(stack,10)
// popå¼¹å‡º
v:=stack[len(stack)-1]
stack=stack[:len(stack)-1]
// æ£€æŸ¥æ ˆç©º
len(stack)==0
```



## é˜Ÿåˆ—

```go
// åˆ›å»ºé˜Ÿåˆ—
queue:=make([]int,0)
// enqueueå…¥é˜Ÿ
queue=append(queue,10)
// dequeueå‡ºé˜Ÿ
v:=queue[0]
queue=queue[1:]
// é•¿åº¦0ä¸ºç©º
len(queue)==0
```



## ç›¸å…³ç»ƒä¹ é¢˜

[20. æœ‰æ•ˆçš„æ‹¬å·](https://leetcode.cn/problems/valid-parentheses/)

```go
/*
ç»™å®šä¸€ä¸ªåªåŒ…æ‹¬ '('ï¼Œ')'ï¼Œ'{'ï¼Œ'}'ï¼Œ'['ï¼Œ']' çš„å­—ç¬¦ä¸² s ï¼Œåˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦æœ‰æ•ˆã€‚

æœ‰æ•ˆå­—ç¬¦ä¸²éœ€æ»¡è¶³ï¼š

å·¦æ‹¬å·å¿…é¡»ç”¨ç›¸åŒç±»å‹çš„å³æ‹¬å·é—­åˆã€‚
å·¦æ‹¬å·å¿…é¡»ä»¥æ­£ç¡®çš„é¡ºåºé—­åˆã€‚
æ¯ä¸ªå³æ‹¬å·éƒ½æœ‰ä¸€ä¸ªå¯¹åº”çš„ç›¸åŒç±»å‹çš„å·¦æ‹¬å·ã€‚


ç¤ºä¾‹ 1ï¼š

è¾“å…¥ï¼šs = "()"
è¾“å‡ºï¼štrue
ç¤ºä¾‹ 2ï¼š

è¾“å…¥ï¼šs = "()[]{}"
è¾“å‡ºï¼štrue
ç¤ºä¾‹ 3ï¼š

è¾“å…¥ï¼šs = "(]"
è¾“å‡ºï¼šfalse


æç¤ºï¼š

1 <= s.length <= 104
s ä»…ç”±æ‹¬å· '()[]{}' ç»„æˆ


ğŸ§  è§£é¢˜æ€è·¯
åˆ¤æ–­æ‹¬å·çš„æœ‰æ•ˆæ€§å¯ä»¥ä½¿ç”¨ã€Œæ ˆã€è¿™ä¸€æ•°æ®ç»“æ„æ¥è§£å†³ã€‚

æˆ‘ä»¬éå†ç»™å®šçš„å­—ç¬¦ä¸² sã€‚å½“æˆ‘ä»¬é‡åˆ°ä¸€ä¸ªå·¦æ‹¬å·æ—¶ï¼Œæˆ‘ä»¬ä¼šæœŸæœ›åœ¨åç»­çš„éå†ä¸­ï¼Œæœ‰ä¸€ä¸ªç›¸åŒç±»å‹çš„å³æ‹¬å·å°†å…¶é—­åˆã€‚ç”±äºåé‡åˆ°çš„å·¦æ‹¬å·è¦å…ˆé—­åˆï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å°†è¿™ä¸ªå·¦æ‹¬å·æ”¾å…¥æ ˆé¡¶ã€‚

å½“æˆ‘ä»¬é‡åˆ°ä¸€ä¸ªå³æ‹¬å·æ—¶ï¼Œæˆ‘ä»¬éœ€è¦å°†ä¸€ä¸ªç›¸åŒç±»å‹çš„å·¦æ‹¬å·é—­åˆã€‚æ­¤æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥å–å‡ºæ ˆé¡¶çš„å·¦æ‹¬å·å¹¶åˆ¤æ–­å®ƒä»¬æ˜¯å¦æ˜¯ç›¸åŒç±»å‹çš„æ‹¬å·ã€‚å¦‚æœä¸æ˜¯ç›¸åŒçš„ç±»å‹ï¼Œæˆ–è€…æ ˆä¸­å¹¶æ²¡æœ‰å·¦æ‹¬å·ï¼Œé‚£ä¹ˆå­—ç¬¦ä¸² s æ— æ•ˆï¼Œè¿”å› Falseã€‚ä¸ºäº†å¿«é€Ÿåˆ¤æ–­æ‹¬å·çš„ç±»å‹ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å“ˆå¸Œè¡¨å­˜å‚¨æ¯ä¸€ç§æ‹¬å·ã€‚å“ˆå¸Œè¡¨çš„é”®ä¸ºå³æ‹¬å·ï¼Œå€¼ä¸ºç›¸åŒç±»å‹çš„å·¦æ‹¬å·ã€‚

åœ¨éå†ç»“æŸåï¼Œå¦‚æœæ ˆä¸­æ²¡æœ‰å·¦æ‹¬å·ï¼Œè¯´æ˜æˆ‘ä»¬å°†å­—ç¬¦ä¸² s ä¸­çš„æ‰€æœ‰å·¦æ‹¬å·é—­åˆï¼Œè¿”å› Trueï¼Œå¦åˆ™è¿”å› Falseã€‚

æ³¨æ„åˆ°æœ‰æ•ˆå­—ç¬¦ä¸²çš„é•¿åº¦ä¸€å®šä¸ºå¶æ•°ï¼Œå› æ­¤å¦‚æœå­—ç¬¦ä¸²çš„é•¿åº¦ä¸ºå¥‡æ•°ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥è¿”å› Falseï¼Œçœå»åç»­çš„éå†åˆ¤æ–­è¿‡ç¨‹ã€‚

*/

func isValid(s string) bool {
    n := len(s)
    // æ³¨æ„åˆ°æœ‰æ•ˆå­—ç¬¦ä¸²çš„é•¿åº¦ä¸€å®šä¸ºå¶æ•°ï¼Œå› æ­¤å¦‚æœå­—ç¬¦ä¸²çš„é•¿åº¦ä¸ºå¥‡æ•°ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥è¿”å› Falseï¼Œçœå»åç»­çš„éå†åˆ¤æ–­è¿‡ç¨‹ã€‚
    if n % 2 == 1 {
        return false
    }
    // ä½¿ç”¨ rune ç±»å‹å­˜å‚¨æ‹¬å·å¯¹ï¼Œæé«˜æ•ˆç‡
    m := map[rune]rune{
        '(': ')',
        '{': '}',
        '[': ']',
    }
    
    // ä½¿ç”¨åŠ¨æ€åˆ‡ç‰‡å®ç°æ ˆ
    var stack []rune
    
    // ç›´æ¥è¿­ä»£å­—ç¬¦ä¸²çš„å­—ç¬¦ï¼Œé¿å…ä½¿ç”¨ strings.Split
    for _, char := range s {
        // å¦‚æœæ˜¯å¼€æ‹¬å·ï¼Œå‹å…¥æ ˆ
        if _, ok := m[char]; ok {
            stack = append(stack, char)
        } else {
            // å¦‚æœæ˜¯é—­æ‹¬å·
            // æ£€æŸ¥æ ˆæ˜¯å¦ä¸ºç©º
            if len(stack) == 0 {
                return false
            }
            
            // è·å–æ ˆé¡¶çš„å¼€æ‹¬å·
            lastOpening := stack[len(stack)-1]
            
            // æ£€æŸ¥æ˜¯å¦åŒ¹é…
            if m[lastOpening] != char {
                return false
            }
            
            // å¼¹å‡ºæ ˆé¡¶å…ƒç´ 
            stack = stack[:len(stack)-1]
        }
    }
    
    // æ£€æŸ¥æ ˆæ˜¯å¦ä¸ºç©º
    return len(stack) == 0
}




```



[232. ç”¨æ ˆå®ç°é˜Ÿåˆ—](https://leetcode.cn/problems/implement-queue-using-stacks/)

```go
/*
è¯·ä½ ä»…ä½¿ç”¨ä¸¤ä¸ªæ ˆå®ç°å…ˆå…¥å…ˆå‡ºé˜Ÿåˆ—ã€‚é˜Ÿåˆ—åº”å½“æ”¯æŒä¸€èˆ¬é˜Ÿåˆ—æ”¯æŒçš„æ‰€æœ‰æ“ä½œï¼ˆpushã€popã€peekã€emptyï¼‰ï¼š

å®ç° MyQueue ç±»ï¼š

void push(int x) å°†å…ƒç´  x æ¨åˆ°é˜Ÿåˆ—çš„æœ«å°¾
int pop() ä»é˜Ÿåˆ—çš„å¼€å¤´ç§»é™¤å¹¶è¿”å›å…ƒç´ 
int peek() è¿”å›é˜Ÿåˆ—å¼€å¤´çš„å…ƒç´ 
boolean empty() å¦‚æœé˜Ÿåˆ—ä¸ºç©ºï¼Œè¿”å› true ï¼›å¦åˆ™ï¼Œè¿”å› false
è¯´æ˜ï¼š

ä½  åªèƒ½ ä½¿ç”¨æ ‡å‡†çš„æ ˆæ“ä½œ â€”â€” ä¹Ÿå°±æ˜¯åªæœ‰ push to top, peek/pop from top, size, å’Œ is empty æ“ä½œæ˜¯åˆæ³•çš„ã€‚
ä½ æ‰€ä½¿ç”¨çš„è¯­è¨€ä¹Ÿè®¸ä¸æ”¯æŒæ ˆã€‚ä½ å¯ä»¥ä½¿ç”¨ list æˆ–è€… dequeï¼ˆåŒç«¯é˜Ÿåˆ—ï¼‰æ¥æ¨¡æ‹Ÿä¸€ä¸ªæ ˆï¼Œåªè¦æ˜¯æ ‡å‡†çš„æ ˆæ“ä½œå³å¯ã€‚


ç¤ºä¾‹ 1ï¼š

è¾“å…¥ï¼š
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
è¾“å‡ºï¼š
[null, null, null, 1, 1, false]

ğŸ§  è§£é¢˜æ€è·¯
é˜Ÿåˆ—çš„ç‰¹æ€§æ˜¯ FIFOï¼ˆå…ˆå…¥å…ˆå‡ºï¼‰ï¼Œè€Œæ ˆçš„ç‰¹æ€§æ˜¯ FILOï¼ˆå…ˆå…¥åå‡ºï¼‰ã€‚

çŸ¥é“ä¸¤è€…ç‰¹æ€§ä¹‹åï¼Œæˆ‘ä»¬éœ€è¦ç”¨ä¸¤ä¸ªæ ˆæ¥æ¨¡æ‹Ÿé˜Ÿåˆ—çš„ç‰¹æ€§ï¼Œä¸€ä¸ªæ ˆä¸ºå…¥é˜Ÿæ ˆï¼Œä¸€ä¸ªæ ˆä¸ºå‡ºå¯¹æ ˆã€‚

å½“å‡ºé˜Ÿæ ˆå­˜åœ¨å†…å®¹æ—¶ï¼Œå‡ºé˜Ÿæ ˆçš„æ ˆé¡¶ï¼Œå³ä¸ºç¬¬ä¸€ä¸ªå‡ºé˜Ÿçš„å…ƒç´ ã€‚

è‹¥å‡ºé˜Ÿæ ˆæ— å…ƒç´ ï¼Œæˆ‘ä»¬çš„éœ€æ±‚åˆæ˜¯å‡ºé˜Ÿçš„è¯ï¼Œæˆ‘ä»¬å°±éœ€è¦å°†å…¥é˜Ÿæ ˆçš„å†…å®¹ååºå¯¼å…¥å‡ºé˜Ÿæ ˆï¼Œç„¶åå¼¹å‡ºæ ˆé¡¶å³å¯ã€‚

æ³¨æ„ï¼šæ ¹æ®æ ˆçš„çš„ç‰¹æ€§ï¼Œæˆ‘ä»¬ä»…èƒ½ä½¿ç”¨ push å’Œ pop æ“ä½œã€‚

*/


type MyQueue struct {
	in, out []int
}

func Constructor() MyQueue {
	return MyQueue{in: make([]int, 0), out: make([]int, 0)}
}

func (this *MyQueue) Push(x int) {
	for len(this.out) != 0 {
		num := this.out[len(this.out)-1]
		this.in = append(this.in, num)
		this.out = this.out[0 : len(this.out)-1]
	}
	this.in = append(this.in, x)
}

func (this *MyQueue) Pop() int {
	for len(this.in) != 0 {
		num := this.in[len(this.in)-1]
		this.out = append(this.out, num)
		this.in = this.in[0 : len(this.in)-1]
	}
	result := this.out[len(this.out)-1]
	this.out = this.out[0 : len(this.out)-1]
	return result
}

func (this *MyQueue) Peek() int {
	for len(this.in) != 0 {
		num := this.in[len(this.in)-1]
		this.out = append(this.out, num)
		this.in = this.in[0 : len(this.in)-1]
	}
	if len(this.out) == 0 {
		return -1
	}
	return this.out[len(this.out)-1]
}

func (this *MyQueue) Empty() bool {
	return len(this.in) == 0 && len(this.out) == 0
}

```



[225. ç”¨é˜Ÿåˆ—å®ç°æ ˆ](https://leetcode.cn/problems/implement-stack-using-queues/)

```go
/*
è¯·ä½ ä»…ä½¿ç”¨ä¸¤ä¸ªé˜Ÿåˆ—å®ç°ä¸€ä¸ªåå…¥å…ˆå‡ºï¼ˆLIFOï¼‰çš„æ ˆï¼Œå¹¶æ”¯æŒæ™®é€šæ ˆçš„å…¨éƒ¨å››ç§æ“ä½œï¼ˆpushã€topã€pop å’Œ emptyï¼‰ã€‚

å®ç° MyStack ç±»ï¼š

void push(int x) å°†å…ƒç´  x å‹å…¥æ ˆé¡¶ã€‚
int pop() ç§»é™¤å¹¶è¿”å›æ ˆé¡¶å…ƒç´ ã€‚
int top() è¿”å›æ ˆé¡¶å…ƒç´ ã€‚
boolean empty() å¦‚æœæ ˆæ˜¯ç©ºçš„ï¼Œè¿”å› true ï¼›å¦åˆ™ï¼Œè¿”å› false ã€‚


æ³¨æ„ï¼š

ä½ åªèƒ½ä½¿ç”¨é˜Ÿåˆ—çš„åŸºæœ¬æ“ä½œ â€”â€” ä¹Ÿå°±æ˜¯ push to backã€peek/pop from frontã€size å’Œ is empty è¿™äº›æ“ä½œã€‚
ä½ æ‰€ä½¿ç”¨çš„è¯­è¨€ä¹Ÿè®¸ä¸æ”¯æŒé˜Ÿåˆ—ã€‚ ä½ å¯ä»¥ä½¿ç”¨ list ï¼ˆåˆ—è¡¨ï¼‰æˆ–è€… dequeï¼ˆåŒç«¯é˜Ÿåˆ—ï¼‰æ¥æ¨¡æ‹Ÿä¸€ä¸ªé˜Ÿåˆ— , åªè¦æ˜¯æ ‡å‡†çš„é˜Ÿåˆ—æ“ä½œå³å¯ã€‚


ç¤ºä¾‹ï¼š

è¾“å…¥ï¼š
["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
è¾“å‡ºï¼š
[null, null, null, 2, 2, false]

ğŸ§  è§£é¢˜æ€è·¯
æ ¹æ®é¢˜æ„ï¼Œè¦ç”¨ä¸¤ä¸ªé˜Ÿåˆ—æ¥å®ç°æ ˆï¼Œé¦–å…ˆæˆ‘ä»¬çŸ¥é“ï¼Œé˜Ÿåˆ—æ˜¯å…ˆè¿›å…ˆå‡ºï¼Œæ ˆæ˜¯åè¿›å…ˆå‡ºã€‚

çŸ¥é“äº†ä»¥ä¸Šè¦ç‚¹ï¼Œæˆ‘ä»¬ä¸¤ä¸ªé˜Ÿåˆ—çš„ç”¨å¤„ä¹Ÿå°±ä¸€ç›®äº†ç„¶äº†ã€‚

ä¸€ä¸ªé˜Ÿåˆ—ä¸ºä¸»é˜Ÿåˆ—ï¼Œä¸€ä¸ªä¸ºè¾…åŠ©é˜Ÿåˆ—ï¼Œå½“å…¥æ ˆæ“ä½œæ—¶ï¼Œæˆ‘ä»¬å…ˆå°†ä¸»é˜Ÿåˆ—å†…å®¹å¯¼å…¥è¾…åŠ©é˜Ÿåˆ—ï¼Œç„¶åå°†å…¥æ ˆå…ƒç´ æ”¾å…¥ä¸»é˜Ÿåˆ—é˜Ÿå¤´ä½ç½®ï¼Œå†å°†è¾…åŠ©é˜Ÿåˆ—å†…å®¹ï¼Œä¾æ¬¡æ·»åŠ è¿›ä¸»é˜Ÿåˆ—å³å¯ã€‚
*/


type MyStack struct {
	queue1, queue2 []int
}

func Constructor() MyStack {
	return MyStack{queue1: make([]int, 0), queue2: make([]int, 0)}
}

func (this *MyStack) Push(x int) {
	this.queue2 = append(this.queue2, x)
	for len(this.queue1) != 0 {
		tmp := this.queue1[0]
		this.queue1 = this.queue1[1:]
		this.queue2 = append(this.queue2, tmp)
	}
	this.queue1, this.queue2 = this.queue2, this.queue1
}

func (this *MyStack) Pop() int {
	tmp := this.queue1[0]
	this.queue1 = this.queue1[1:]
	return tmp
}

func (this *MyStack) Top() int {
	return this.queue1[0]
}

func (this *MyStack) Empty() bool {
	return len(this.queue1) == 0
}




```