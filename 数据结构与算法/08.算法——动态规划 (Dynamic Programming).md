## 算法专题：动态规划 (Dynamic Programming)

### 1. 引言

在计算机科学和数学中，动态规划（Dynamic Programming，简称 DP）是一种通过把原问题分解为相对简单的子问题的方式来求解复杂问题的方法。它通常用于优化问题，即在给定约束条件下，找到最大或最小的某个值。

动态规划的核心思想是，如果一个问题可以被分解成相互重叠的子问题，并且这些子问题的最优解可以组合成原问题的最优解（即具有最优子结构），那么就可以使用动态规划。通过存储和重用子问题的解，DP 算法避免了重复计算，从而显著提高了效率，通常将指数级的暴力搜索优化到多项式时间。

### 2. 动态规划的两个核心特性

一个问题能够用动态规划解决，通常需要满足以下两个关键性质：

#### 2.1 最优子结构 (Optimal Substructure)

- **定义**：一个问题的最优解包含其子问题的最优解。
- **理解**：这意味着如果你找到了解决一个大问题的最佳方法，那么这个方法所涉及的每个小步骤（子问题）也必须是以最佳方式解决的。
- **例子**：如果最短路径问题中从 A 到 B 的最短路径经过 C，那么从 A 到 C 的路径以及从 C 到 B 的路径也必须是各自的最短路径。

#### 2.2 重叠子问题 (Overlapping Subproblems)

- **定义**：在解决问题的过程中，会多次遇到相同的子问题。
- **理解**：如果子问题是独立的（比如快速排序），那么用分治法就足够了；但如果子问题会被多次计算，那么就可以通过存储子问题的解来避免重复计算，这就是动态规划的优势所在。
- **例子**：计算斐波那契数列 `F(n)`，`F(n) = F(n-1) + F(n-2)`。计算 `F(5)` 需要 `F(4)` 和 `F(3)`，而 `F(4)` 又需要 `F(3)` 和 `F(2)`，`F(3)` 被计算了多次。

### 3. 动态规划的两种实现方式

动态规划通常有两种主要的实现方式：

#### 3.1 记忆化搜索 (Memoization / Top-down DP)

- **思想**：自顶向下，递归地解决问题。在计算子问题时，将结果存储起来（通常在数组或哈希表中）。下次再遇到相同的子问题时，直接从存储中读取，而不是重新计算。
- 优点：
  - 更接近直觉的递归思路，容易编写。
  - 只计算真正需要的子问题。
- 缺点：
  - 递归调用可能导致栈溢出。
  - 有函数调用的额外开销。

#### 3.2 列表法 / 递推 (Tabulation / Bottom-up DP)

- **思想**：自底向上，迭代地解决问题。从最小的子问题开始，逐步计算并填充一个表格（通常是数组），直到计算出原问题的解。
- 优点：
  - 没有递归开销，通常更高效。
  - 避免栈溢出。
  - 更容易进行空间优化。
- 缺点：
  - 需要确定正确的计算顺序。
  - 可能需要计算所有子问题，即使某些子问题对最终解没有贡献。

### 4. 解决动态规划问题的通用步骤

1. **定义 DP 状态**：
   - `dp[i]` 通常表示解决规模为 `i` 的子问题的最优解。
   - `dp[i][j]` 通常表示解决涉及前 `i` 个元素和前 `j` 个元素的子问题的最优解。
   - 这一步至关重要，决定了后续步骤的方向。
2. **确定基本情况 (Base Cases)**：
   - 最简单的、可以直接得出的子问题的解。这些是 DP 表格的起始值。
3. **推导状态转移方程 (Recurrence Relation)**：
   - 这是动态规划的核心。它定义了如何从更小的子问题的解来计算当前子问题的解。
   - 形式通常是 `dp[i] = f(dp[i-k], ...)` 或 `dp[i][j] = f(dp[i-x][j-y], ...)`。
4. **确定计算顺序**：
   - 如果是自底向上的方法，需要确定循环的顺序，以确保在计算 `dp[i]` 时，所有 `f` 所依赖的 `dp` 值都已经计算完毕。
5. **（可选）空间优化**：
   - 如果 `dp[i]` 只依赖于 `dp[i-1]` 或 `dp[i-2]` 等少数几个前值，可以将 DP 数组的大小从 `O(N)` 优化到 `O(1)` 或 `O(k)`。
   - 如果是二维 DP，如果 `dp[i][j]` 只依赖于 `dp[i-1]` 行或 `dp[j-1]` 列，可能可以优化空间。

### 5. 动态规划与贪心算法/回溯算法的区别

- **与贪心算法**：
  - **贪心**：每一步都做出局部最优选择，不考虑全局影响，且不回溯。要求问题具有“贪心选择性质”。通常更简单高效，但适用范围窄。
  - **DP**：考虑所有子问题的最优解，通过组合子问题解来得到全局最优，可能会在计算过程中探索多个路径。要求问题具有“最优子结构”和“重叠子问题”。适用范围更广。
- **与回溯算法**：
  - **回溯**：一种暴力搜索，通过尝试所有可能的路径来找到解，当遇到死路或不满足条件时回溯。通常会进行剪枝来优化。
  - **DP**：在回溯的基础上，通过存储和重用重叠子问题的解来避免重复计算，从而将指数级复杂度降低到多项式级。可以看作是带有记忆化的回溯，或者说是“去掉了重复计算的回溯”。

### 6. Go 语言实现示例

#### 示例1：斐波那契数列 (Fibonacci Number)

**问题**：计算第 `n` 个斐波那契数。`F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2)`。

**1. 记忆化搜索 (Top-down)**

```go
package main

import "fmt"

var memo map[int]int // 用于存储已计算的斐波那契数

func fibMemo(n int) int {
	// 初始化 memo 맵
	if memo == nil {
		memo = make(map[int]int)
	}

	// 1. 基本情况 (Base Cases)
	if n <= 1 {
		return n
	}

	// 2. 检查是否已计算 (重叠子问题)
	if val, ok := memo[n]; ok {
		return val
	}

	// 3. 状态转移方程 (递推关系)
	// fibMemo(n) = fibMemo(n-1) + fibMemo(n-2)
	res := fibMemo(n-1) + fibMemo(n-2)

	// 4. 存储结果
	memo[n] = res
	return res
}

// 清除 memo 供多次测试
func resetMemo() {
	memo = nil
}

func main() {
	fmt.Println("--- 斐波那契数列 (记忆化搜索) ---")
	resetMemo() // 清除之前的记忆
	fmt.Printf("F(10) = %d\n", fibMemo(10)) // 55
	resetMemo()
	fmt.Printf("F(20) = %d\n", fibMemo(20)) // 6765
}
```

**2. 列表法 (Bottom-up)**

```go
package main

import "fmt"

func fibTabulation(n int) int {
	// 1. 基本情况 (Base Cases)
	if n <= 1 {
		return n
	}

	// 2. 定义 DP 状态: dp[i] 表示第 i 个斐波那契数
	dp := make([]int, n+1) // dp 数组大小为 n+1，索引 0 到 n

	// 初始化基本情况
	dp[0] = 0
	dp[1] = 1

	// 3. 确定计算顺序并推导状态转移方程
	// 从小到大计算，确保 dp[i-1] 和 dp[i-2] 已计算
	for i := 2; i <= n; i++ {
		dp[i] = dp[i-1] + dp[i-2]
	}

	return dp[n]
}

func main() {
	fmt.Println("\n--- 斐波那契数列 (列表法) ---")
	fmt.Printf("F(10) = %d\n", fibTabulation(10)) // 55
	fmt.Printf("F(20) = %d\n", fibTabulation(20)) // 6765
	fmt.Printf("F(0) = %d\n", fibTabulation(0))   // 0
	fmt.Printf("F(1) = %d\n", fibTabulation(1))   // 1
}
```

#### 示例2：凑零钱问题 (Coin Change)

**问题**：给定不同面额的硬币 `coins` 和一个总金额 `amount`，计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 **核心思想**：这是一个经典的完全背包问题变种，每个硬币可以使用无限次。

```go
package main

import (
	"fmt"
	"math"
)

// coinChangeMinCoins 凑零钱问题 (最小硬币数)
func coinChangeMinCoins(coins []int, amount int) int {
	// 1. 定义 DP 状态: dp[i] 表示凑成金额 i 所需的最少硬币数
	// 初始化 dp 数组，将所有值设为 amount + 1 (表示无穷大，因为最多 amount 个 1 元硬币)
	dp := make([]int, amount+1)
	for i := range dp {
		dp[i] = amount + 1
	}

	// 2. 基本情况 (Base Cases): 凑成金额 0 需要 0 个硬币
	dp[0] = 0

	// 3. 确定计算顺序并推导状态转移方程
	// 遍历所有可能的金额 (从 1 到 amount)
	for i := 1; i <= amount; i++ {
		// 遍历所有硬币面额
		for _, coin := range coins {
			// 如果当前金额 i 减去当前硬币面额 coin 后不为负数
			// 并且 (i - coin) 这个子问题是有解的 (即 dp[i-coin] 不是无穷大)
			if i >= coin && dp[i-coin] != amount+1 {
				// 状态转移方程: dp[i] = min(dp[i], dp[i - coin] + 1)
				// 意思是：凑成金额 i 的最少硬币数，
				// 要么是当前已知的 dp[i] (不使用当前 coin)，
				// 要么是凑成 (i - coin) 的最少硬币数再加上当前这一个 coin。
				dp[i] = int(math.Min(float64(dp[i]), float64(dp[i-coin]+1)))
			}
		}
	}

	// 4. 返回结果
	if dp[amount] == amount+1 {
		return -1 // 如果 dp[amount] 仍然是无穷大，表示无法凑成
	}
	return dp[amount]
}

func main() {
	fmt.Println("\n--- 凑零钱问题 (最小硬币数) ---")
	coins1 := []int{1, 2, 5}
	amount1 := 11
	fmt.Printf("Coins: %v, Amount: %d -> Min coins: %d\n", coins1, amount1, coinChangeMinCoins(coins1, amount1)) // 期望: 3 (5+5+1)

	coins2 := []int{2}
	amount2 := 3
	fmt.Printf("Coins: %v, Amount: %d -> Min coins: %d\n", coins2, amount2, coinChangeMinCoins(coins2, amount2)) // 期望: -1

	coins3 := []int{1}
	amount3 := 0
	fmt.Printf("Coins: %v, Amount: %d -> Min coins: %d\n", coins3, amount3, coinChangeMinCoins(coins3, amount3)) // 期望: 0

	coins4 := []int{186, 419, 83, 408}
	amount4 := 6249
	fmt.Printf("Coins: %v, Amount: %d -> Min coins: %d\n", coins4, amount4, coinChangeMinCoins(coins4, amount4)) // 期望: 20
}
```

#### 示例3：最长公共子序列 (Longest Common Subsequence, LCS)

**问题**：给定两个字符串 `text1` 和 `text2`，找出这两个字符串的最长公共子序列的长度。子序列是指一个字符串通过删除一些（或不删除）字符而不改变剩余字符的相对顺序得到的新字符串。 **核心思想**：二维 DP。

```go
package main

import "fmt"
import "strings" // 引入 strings 包

// max 辅助函数
func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

// longestCommonSubsequence 最长公共子序列
func longestCommonSubsequence(text1 string, text2 string) int {
	m, n := len(text1), len(text2)

	// 1. 定义 DP 状态: dp[i][j] 表示 text1 的前 i 个字符和 text2 的前 j 个字符的最长公共子序列的长度。
	// (为了方便处理边界情况，dp 数组通常会多一行一列)
	dp := make([][]int, m+1)
	for i := range dp {
		dp[i] = make([]int, n+1)
	}

	// 2. 基本情况 (Base Cases):
	// dp[0][j] = 0 (text1 空字符串)
	// dp[i][0] = 0 (text2 空字符串)
	// Go 语言中 int 数组默认初始化为 0，所以这里无需显式设置

	// 3. 确定计算顺序并推导状态转移方程
	// 从左上到右下，逐行逐列计算
	for i := 1; i <= m; i++ {
		for j := 1; j <= n; j++ {
			// 如果当前字符匹配
			if text1[i-1] == text2[j-1] { // 注意：字符串索引从 0 开始，所以是 i-1 和 j-1
				// 状态转移方程 1: 如果当前字符相同，则 LCS 长度加 1，来源于左上角对角线的值
				dp[i][j] = dp[i-1][j-1] + 1
			} else {
				// 如果当前字符不匹配
				// 状态转移方程 2: LCS 长度等于 (text1 往前一个字符的 LCS) 和 (text2 往前一个字符的 LCS) 中的较大值
				dp[i][j] = max(dp[i-1][j], dp[i][j-1])
			}
		}
	}

	// 4. 返回结果
	return dp[m][n] // dp[m][n] 即为 text1 和 text2 的 LCS 长度
}

func main() {
	fmt.Println("\n--- 最长公共子序列 ---")
	text1_1 := "abcde"
	text2_1 := "ace"
	fmt.Printf("Text1: \"%s\", Text2: \"%s\" -> LCS Length: %d\n", text1_1, text2_1, longestCommonSubsequence(text1_1, text2_1)) // 期望: 3 ("ace")

	text1_2 := "abc"
	text2_2 := "abc"
	fmt.Printf("Text1: \"%s\", Text2: \"%s\" -> LCS Length: %d\n", text1_2, text2_2, longestCommonSubsequence(text1_2, text2_2)) // 期望: 3 ("abc")

	text1_3 := "abc"
	text2_3 := "def"
	fmt.Printf("Text1: \"%s\", Text2: \"%s\" -> LCS Length: %d\n", text1_3, text2_3, longestCommonSubsequence(text1_3, text2_3)) // 期望: 0
}
```

#### 示例4：0/1 背包问题 (0/1 Knapsack Problem)

**问题**：给定 `n` 件物品和一个容量为 `W` 的背包。每件物品有其价值 `value[i]` 和重量 `weight[i]`。每件物品只能选择一次（0/1），问在不超过背包容量的前提下，如何使得背包中物品的总价值最大。 **核心思想**：二维 DP。

```go
package main

import "fmt"

// knapsack01 解决 0/1 背包问题
func knapsack01(weights []int, values []int, W int) int {
	n := len(weights) // 物品数量

	// 1. 定义 DP 状态: dp[i][w] 表示从前 i 件物品中选择，在背包容量为 w 的情况下，所能获得的最大总价值。
	// dp 数组大小为 (n+1) * (W+1)，索引从 0 开始
	dp := make([][]int, n+1)
	for i := range dp {
		dp[i] = make([]int, W+1)
	}

	// 2. 基本情况 (Base Cases):
	// dp[0][w] = 0 (没有物品可选时，价值为 0)
	// dp[i][0] = 0 (背包容量为 0 时，价值为 0)
	// Go 语言中 int 数组默认初始化为 0，所以这里无需显式设置

	// 3. 确定计算顺序并推导状态转移方程
	// 遍历物品 (从 1 到 n)
	for i := 1; i <= n; i++ {
		// 遍历背包容量 (从 1 到 W)
		for w := 1; w <= W; w++ {
			// 当前物品的重量和价值 (注意：物品索引是 i-1)
			currentWeight := weights[i-1]
			currentValue := values[i-1]

			// 如果当前物品的重量大于当前背包容量 w
			if currentWeight > w {
				// 状态转移方程 1: 无法放入当前物品，最大价值等于不放入当前物品时的价值
				dp[i][w] = dp[i-1][w]
			} else {
				// 如果可以放入当前物品，有两种选择：
				// 状态转移方程 2: max(不放入当前物品, 放入当前物品)
				// 不放入：dp[i-1][w] (即当前物品的价值为 0)
				// 放入：dp[i-1][w - currentWeight] + currentValue
				// (即：放入当前物品后，背包容量减少 currentWeight，剩余容量的最大价值加上当前物品的价值)
				dp[i][w] = max(dp[i-1][w], dp[i-1][w-currentWeight]+currentValue)
			}
		}
	}

	// 4. 返回结果
	return dp[n][W] // dp[n][W] 即为所有物品在容量 W 下的最大总价值
}

func main() {
	fmt.Println("\n--- 0/1 背包问题 ---")
	// 物品：价值, 重量
	// Item 1: (60, 10)
	// Item 2: (100, 20)
	// Item 3: (120, 30)

	weights1 := []int{10, 20, 30}
	values1 := []int{60, 100, 120}
	capacity1 := 50
	fmt.Printf("Weights: %v, Values: %v, Capacity: %d -> Max Value: %d\n", weights1, values1, capacity1, knapsack01(weights1, values1, capacity1))
	// 期望: 220 (选择物品2和物品3: 100+120=220, 重量20+30=50)

	weights2 := []int{2, 3, 4, 5}
	values2 := []int{3, 4, 5, 6}
	capacity2 := 5
	fmt.Printf("Weights: %v, Values: %v, Capacity: %d -> Max Value: %d\n", weights2, values2, capacity2, knapsack01(weights2, values2, capacity2))
	// 期望: 7 (选择物品2和物品3: 3+4=7, 重量2+3=5)
}
```

### 7. 结论

动态规划是一种强大而通用的算法设计范式，它通过识别问题的最优子结构和重叠子问题，并运用记忆化或列表法来避免重复计算，从而高效地解决许多复杂的优化问题。掌握 DP 的核心思想、通用步骤和常见题型，是提升算法能力的基石。虽然它的概念可能初看起来有些抽象，但通过大量的练习和 Go 语言的清晰实现，你会逐渐领悟其精妙之处。