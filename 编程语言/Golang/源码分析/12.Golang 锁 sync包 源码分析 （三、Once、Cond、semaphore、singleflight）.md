# Golang 锁 sync包 源码分析 （三、Once、Cond、semaphore、singleflight）

> 注意当前go版本代码为1.23
>
> sync包 源码分析包主要介绍 Go 语言中常见的同步原语 [`sync.Mutex`](https://draveness.me/golang/tree/sync.Mutex)、[`sync.RWMutex`](https://draveness.me/golang/tree/sync.RWMutex)、[`sync.WaitGroup`](https://draveness.me/golang/tree/sync.WaitGroup)、[`sync.Once`](https://draveness.me/golang/tree/sync.Once) 和 [`sync.Cond`](https://draveness.me/golang/tree/sync.Cond) 以及扩展原语 [`golang/sync/errgroup.Group`](https://draveness.me/golang/tree/golang/sync/errgroup.Group)、[`golang/sync/semaphore.Weighted`](https://draveness.me/golang/tree/golang/sync/semaphore.Weighted) 和 [`golang/sync/singleflight.Group`](https://draveness.me/golang/tree/golang/sync/singleflight.Group) 的实现原理，同时也会涉及互斥锁、信号量等并发编程中的常见概念。

## Once

### 示例

```go
func main() {
    o := &sync.Once{}
    for i := 0; i < 10; i++ {
        o.Do(func() {
            fmt.Println("only once")
        })
    }
}

$ go run main.go
输出：only once
```

### 源码

```go
// Once 是一个用于确保某个操作只执行一次的结构体。
// 它通常用于初始化、资源加载等场景，确保即使在并发环境下，操作也只会执行一次。
type Once struct {
    // done 是一个原子变量，用于指示操作是否已经执行。
    done atomic.Uint32

    // m 是一个互斥锁，用于在doSlow 中保护临界区。
    m    Mutex
}

// Do 方法用于执行传入的函数 f，并确保 f 只会被执行一次。
// 如果 Once 实例已经被标记为“已完成”（done == 1），则 f 不会被执行。
// 否则，f 会被执行，并且 Once 实例会被标记为“已完成”。
func (o *Once) Do(f func()) {
   		// 首先检查 done 是否为 0，即操作是否尚未执行。
     	// 如果 done 为 0，则进入doSlow执行操作。
        if o.done.Load() == 0 {
                o.doSlow(f)
        }
}

// doSlow 是 Do 方法的慢路径实现，用于处理并发情况。
// 它通过互斥锁 m 来确保只有一个 goroutine 能够执行操作。
func (o *Once) doSlow(f func()) {
        o.m.Lock()
   		 // 在函数返回时释放互斥锁，确保锁总是会被释放。
        defer o.m.Unlock()

    	// 再次检查 done 是否为 0，因为在获取锁的过程中，其他 goroutine 可能已经执行了操作。
    	// 如果 done 仍然为 0，则执行操作。
        if o.done.Load() == 0 {
        		 // 在函数返回时将 done 设置为 1，标记操作已经完成。
       			 // 使用 defer 确保即使 f 发生 panic，done 也会被正确设置。
                defer o.done.Store(1)
        		// 执行传入的函数 f。
                f()
        }
}
```

Go 语言标准库中 [`sync.Once`](https://draveness.me/golang/tree/sync.Once) 可以保证在 Go 程序运行期间的某段代码只会执行一次。

[`sync.Once.Do`](https://draveness.me/golang/tree/sync.Once.Do) 是 [`sync.Once`](https://draveness.me/golang/tree/sync.Once) 结构体对外唯一暴露的方法，该方法会接收一个入参为空的函数：

- 如果传入的函数已经执行过，会直接返回；
- 如果传入的函数没有执行过，会调用 [`sync.Once.doSlow`](https://draveness.me/golang/tree/sync.Once.doSlow) 执行传入的函数：

[`sync.Once`](https://draveness.me/golang/tree/sync.Once) 会通过成员变量 `done` 设置为1确保函数不会执行第二次。





## Cond 

### 示例

```go
var status int64

func main() {
    c := sync.NewCond(&sync.Mutex{})
    for i := 0; i < 5; i++ {
       go listen(c)
    }
    time.Sleep(1 * time.Second)
    go broadcast(c)
}

func broadcast(c *sync.Cond) {
    c.L.Lock()
    atomic.StoreInt64(&status, 1)
    c.Broadcast()
    c.L.Unlock()
}

func listen(c *sync.Cond) {
    c.L.Lock()
    for atomic.LoadInt64(&status) != 1 {
       c.Wait()
    }
    fmt.Println("listen")
    c.L.Unlock()
}

$ go run main.go
输出：
listen
listen
listen
listen
listen

```

### 源码





## 参考链接

1.3.[Go 语言设计与实现](https://draveness.me/golang)