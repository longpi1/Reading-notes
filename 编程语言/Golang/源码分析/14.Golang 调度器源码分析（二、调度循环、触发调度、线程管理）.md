# Golang 调度器源码分析（二、调度循环、触发调度、线程管理）

> 注意当前go版本代码为1.23



## 介绍

关于Golang的协程调度器原理及GMP设计思想可以通过[Golang的协程调度器原理及GMP设计思想](https://github.com/longpi1/Reading-notes/blob/main/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/Golang%E7%9A%84%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E5%8F%8AGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3.md)进行了解，相关基础结构与启动以及创建源码可查看上一篇文章，这一篇文章主要介绍调度器的调度循环实现、触发调度的时机以及线程管理。



## 调度循环

```go
// schedule 执行一轮调度：寻找一个可运行的 goroutine 并执行它。
// 该函数永不返回。
func schedule() {
        // 获取当前 goroutine 的 M（机器，代表线程）
        mp := getg().m

///......忽略非核心代码

top:
        // 获取当前 M 绑定的 P（处理器，代表调度资源）
        pp := mp.p.ptr()
        // 重置 P 的抢占标志，表明当前不处于抢占状态
        pp.preempt = false

///......忽略非核心代码

        // 寻找一个可运行的 goroutine，可能会阻塞直到有工作可用
        // 返回值：
        // - gp: 可运行的 goroutine
        // - inheritTime: 是否继承时间片（用于某些特殊 goroutine，如 GC worker）
        // - tryWakeP: 是否需要唤醒一个空闲的 P
        gp, inheritTime, tryWakeP := findRunnable()

    ///......忽略非核心代码
 

        // 执行找到的 goroutine，inheritTime 表示是否继承时间片。
        // 该函数永不返回，当前 M 将继续执行该 goroutine。
        execute(gp, inheritTime)
}
```

[`runtime.schedule`](https://draveness.me/golang/tree/runtime.schedule) 函数主要通过[`runtime.findrunnable`](https://draveness.me/golang/tree/runtime.findrunnable) 去实现协程的寻找。再调用execute实现执行

[`runtime.findrunnable`](https://draveness.me/golang/tree/runtime.findrunnable) 的实现非常复杂，这个 300 多行的函数通过以下的过程获取可运行的 Goroutine：

```go
// Finds a runnable goroutine to execute.
// 查找一个可运行的 goroutine 来执行。
// Tries to steal from other P's, get g from local or global queue, poll network.
// 尝试从其他 P 窃取，从本地或全局队列获取 G，轮询网络。
// tryWakeP indicates that the returned goroutine is not normal (GC worker, trace
// reader) so the caller should try to wake a P.
// tryWakeP 指示返回的 goroutine 不是普通的 goroutine (例如 GC worker, trace reader)，
// 因此调用者应该尝试唤醒一个 P。
func findRunnable() (gp *g, inheritTime, tryWakeP bool) {
    mp := getg().m // 获取当前 M

top:
    pp := mp.p.ptr() // 获取当前 M 绑定的 P
    if sched.gcwaiting.Load() {
       // 如果调度器正在等待 GC，则停止当前 M
       gcstopm()
       goto top // 跳转到 top 重新查找
    }
    
    ///......忽略非核心代码

    // Check the global runnable queue once in a while to ensure fairness.
    // 1.每隔一段时间检查一次全局可运行队列，以确保公平性。
    // 否则，两个 goroutine 可以通过不断地相互重新生成来完全占据本地运行队列。
    if pp.schedtick%61 == 0 && sched.runqsize > 0 {
       lock(&sched.lock)
       gp := globrunqget(pp, 1) // 从全局运行队列中获取一个 goroutine
       unlock(&sched.lock)
       if gp != nil {
          return gp, false, false // 返回从全局队列获取的 goroutine，不需要继承时间，不需要唤醒 P
       }
    }

    ///......忽略非核心代码

    // local runq
    // 2.从本地运行队列获取
    if gp, inheritTime := runqget(pp); gp != nil {
       return gp, inheritTime, false // 返回从本地队列获取的 goroutine，可能需要继承时间，不需要唤醒 P
    }

    // global runq
    // 3.从全局运行队列获取
    if sched.runqsize != 0 {
       lock(&sched.lock)
       gp := globrunqget(pp, 0) // 从全局运行队列中获取一个 goroutine
       unlock(&sched.lock)
       if gp != nil {
          return gp, false, false // 返回从全局队列获取的 goroutine，不需要继承时间，不需要唤醒 P
       }
    }

    // Poll network.
    // 4.轮询网络。
    // This netpoll is only an optimization before we resort to stealing.
    // 这种网络轮询只是在我们诉诸窃取之前的一种优化。
    // 如果没有等待者或线程已经在 netpoll 中阻塞，我们可以安全地跳过它。
    // 如果与该阻塞线程存在任何类型的逻辑竞争（例如，它已经从 netpoll 返回，但尚未设置 lastpoll），
    // 则此线程无论如何都将在下面执行阻塞 netpoll。
    if netpollinited() && netpollAnyWaiters() && sched.lastpoll.Load() != 0 {
       if list, delta := netpoll(0); !list.empty() { // non-blocking 非阻塞网络轮询
          gp := list.pop()
          injectglist(&list)
          netpollAdjustWaiters(delta)
          trace := traceAcquire()
          casgstatus(gp, _Gwaiting, _Grunnable) // 将 goroutine 状态从 _Gwaiting 更改为 _Grunnable
          if trace.ok() {
             trace.GoUnpark(gp, 0)
             traceRelease(trace)
          }
          return gp, false, false // 返回从网络轮询获取的 goroutine，不需要继承时间，不需要唤醒 P
       }
    }

    // 5.自旋的 M：从其他 P 窃取工作。
    // 将自旋 M 的数量限制为繁忙 P 数量的一半。
    // 这是必要的，以防止当 GOMAXPROCS>>1 但程序并行度较低时过多的 CPU 消耗。
    if mp.spinning || 2*sched.nmspinning.Load() < gomaxprocs-sched.npidle.Load() {
       if !mp.spinning {
          mp.becomeSpinning() // 将当前 M 设置为自旋状态
       }

       gp, inheritTime, tnow, w, newWork := stealWork(now) // 尝试从其他 P 窃取工作
       if gp != nil {
          // Successfully stole.
          // 成功窃取。
          return gp, inheritTime, false // 返回窃取的 goroutine，可能需要继承时间，不需要唤醒 P
       }
       if newWork {
          // There may be new timer or GC work; restart to
          // discover.
          // 可能有新的计时器或 GC 工作；重新启动以发现。
          goto top
       }

       now = tnow
       if w != 0 && (pollUntil == 0 || w < pollUntil) {
          // Earlier timer to wait for.
          // 有更早的计时器需要等待。
          pollUntil = w
       }
    }
    ///......忽略非核心代码

}
```

### **主要步骤流程总结：**

1. **尝试从本地和全局队列获取 G:**
   - **全局队列 (公平性):** 为了保证公平性，每隔一段时间（`pp.schedtick%61 == 0`）且全局队列不为空时，尝试从全局队列获取一个 G。
   - **唤醒 finalizer G:** 如果finalizer goroutine处于等待唤醒状态, 唤醒它。
   - **CGO 让出：** 如果是cgo环境, 尝试让出cpu给c线程。
   - **本地队列:** 尝试从当前 P 的本地运行队列获取一个 G。如果获取成功，则直接返回。
   - **全局队列:** 如果本地队列为空，则尝试从全局运行队列获取一个 G。
2. **尝试非阻塞网络轮询 (Netpoll, 优化):**
   - 如果网络轮询已初始化、有等待者，并且上次轮询时间不为 0，则尝试进行非阻塞网络轮询 (`netpoll(0)`)。
   - 如果轮询到可运行的 G，则将其状态设置为 `_Grunnable` 并返回。
3.  [`runtime.runqsteal`](https://draveness.me/golang/tree/runtime.runqsteal)**尝试从其他 P 窃取工作 (Work Stealing):**
   - 如果当前 M 是自旋状态，或者自旋 M 的数量小于限制（繁忙 P 数量的一半），则尝试从其他 P 窃取工作 (`stealWork()`)。
   - 如果窃取成功，则直接返回窃取到的 G。
   - 如果窃取失败，但发现了新的工作（例如新的 timer 或 GC 工作），则重新开始查找循环 (`goto top`)。
4. **尝试运行空闲时间 GC 标记 (Idle-time GC Marking):**
   - 如果 GC 标记启用、有可用的 GC 标记工作，并且可以添加空闲标记 worker，则尝试从 worker 池中获取一个 worker 并运行。
   - 如果获取成功，则将 P 的 GC 标记模式设置为 `gcMarkWorkerIdleMode`，将 worker goroutine 的状态设置为 `_Grunnable`，并返回该 goroutine。
5. **WASM 特殊处理:**
   - 如果回调返回并且没有其他 goroutine 被唤醒，则尝试获取并唤醒事件处理程序 goroutine。
6. **准备释放 P 并阻塞:**
   - 在释放 P 之前，创建 `allp`、`idlepMask` 和 `timerpMask` 的快照，以防止在释放 P 后这些数据被修改。
   - 获取全局锁 (`sched.lock`)。
   - 再次检查 GC 等待和安全点函数。
   - 再次检查全局运行队列。
   - 再次检查是否需要自旋的M。
   - 释放当前 P (`releasep()`)。
   - 将当前 P 放入空闲 P 列表 (`pidleput()`)。
   - 释放全局锁 (`unlock(&sched.lock)`)。
7. **处理从自旋到非自旋状态的转换（微妙的舞蹈）**
   - 如果当前 M 是自旋状态（`mp.spinning`），取消自旋状态并减少自旋计数（`nmspinning`）。
   - 为了防止遗漏工作，重新检查以下来源：
     - 全局和 P 运行队列
       - 如果全局队列不为空，尝试获取空闲 P 并从中获取 goroutine，返回该 goroutine。
       - 检查所有 P 的运行队列（`checkRunqsNoP`），若找到工作，获取 P 并跳转到 `top`。
     - 空闲优先级的 GC 工作
       - 检查是否有空闲 GC 工作（`checkIdleGCNoP`），若有则获取 P，唤醒相关 goroutine 并返回。
     - 定时器
       - 检查是否有新创建或到期的定时器（`checkTimersNoP`），更新 `pollUntil`。
   - 如果发现新工作且没有空闲 P，需要恢复自旋状态以确保工作不会丢失。
8. **轮询网络直到下一个定时器到期**
   - 如果网络轮询已初始化（`netpollinited`），且有等待者或 `pollUntil != 0`，且上次轮询时间非零：
     - 设置 `pollUntil`，计算阻塞延迟（`delay`）。
     - 执行阻塞式网络轮询（`netpoll(delay)`），获取事件列表。
     - 更新时间和轮询状态。
     - 如果使用假时间（`faketime != 0`）且列表为空，停止 M 并跳转到 `top`。
     - 如果获取到空闲 P：
       - 从事件列表中获取 goroutine，唤醒并返回。
       - 如果列表为空但之前是自旋状态，恢复自旋并跳转到 `top`。
     - 如果未获取到空闲 P，将事件列表注入全局队列，调整等待者计数。
   - 如果 `pollUntil != 0` 且网络轮询已初始化，检查是否需要中断轮询（`netpollBreak`）。
9. **停止当前 M 并重新开始循环**
   - 调用 `stopm()` 停止当前 M。
   - 跳转到 `top` 重新开始循环，寻找可运行的工作。
   - 总而言之，当前函数一定会返回一个可执行的 Goroutine，如果当前不存在就会阻塞等待。



接下来由 [`runtime.execute`](https://draveness.me/golang/tree/runtime.execute) 执行获取的 Goroutine，做好准备工作后，它会通过 [`runtime.gogo`](https://draveness.me/golang/tree/runtime.gogo) 将 Goroutine 调度到当前线程上。

```go
func execute(gp *g, inheritTime bool) {
    mp := getg().m

    // .....忽略非核心代码

    // Assign gp.m before entering _Grunning so running Gs have an
    // M.
    mp.curg = gp
    gp.m = mp
    casgstatus(gp, _Grunnable, _Grunning)
    gp.waitsince = 0
    gp.preempt = false
    gp.stackguard0 = gp.stack.lo + stackGuard
    if !inheritTime {
       mp.p.ptr().schedtick++
    }

    // .....忽略非核心代码

    gogo(&gp.sched)
}
```

[`runtime.gogo`](https://draveness.me/golang/tree/runtime.gogo) 在不同处理器架构上的实现都不同，但是也都大同小异，下面是该函数在 386 架构上的实现：

```go
TEXT runtime·gogo(SB), NOSPLIT, $8-4
	MOVL buf+0(FP), BX     // 获取调度信息
	MOVL gobuf_g(BX), DX
	MOVL 0(DX), CX         // 保证 Goroutine 不为空
	get_tls(CX)
	MOVL DX, g(CX)
	MOVL gobuf_sp(BX), SP  // 将 runtime.goexit 函数的 PC 恢复到 SP 中
	MOVL gobuf_ret(BX), AX
	MOVL gobuf_ctxt(BX), DX
	MOVL $0, gobuf_sp(BX)
	MOVL $0, gobuf_ret(BX)
	MOVL $0, gobuf_ctxt(BX)
	MOVL gobuf_pc(BX), BX  // 获取待执行函数的程序计数器
	JMP  BX                // 开始执行
```

它从 [`runtime.gobuf`](https://draveness.me/golang/tree/runtime.gobuf) 中取出了 [`runtime.goexit`](https://draveness.me/golang/tree/runtime.goexit) 的程序计数器和待执行函数的程序计数器，其中：

- [`runtime.goexit`](https://draveness.me/golang/tree/runtime.goexit) 的程序计数器被放到了栈 SP 上；
- 待执行函数的程序计数器被放到了寄存器 BX 上；

Go 语言的调用惯例中正常的函数调用都会使用 `CALL` 指令，该指令会将调用方的返回地址加入栈寄存器 SP 中，然后跳转到目标函数；当目标函数返回后，会从栈中查找调用的地址并跳转回调用方继续执行剩下的代码。

[`runtime.gogo`](https://draveness.me/golang/tree/runtime.gogo) 就利用了 Go 语言的调用惯例成功模拟这一调用过程，通过以下几个关键指令模拟 `CALL` 的过程：

```go
	MOVL gobuf_sp(BX), SP  // 将 runtime.goexit 函数的 PC 恢复到 SP 中
	MOVL gobuf_pc(BX), BX  // 获取待执行函数的程序计数器
	JMP  BX                // 开始执行
```

![golang-gogo-stack](https://img.draveness.me/2020-02-05-15808864354661-golang-gogo-stack.png)

**图:runtime.gogo 栈内存**

上图展示了调用 `JMP` 指令后的栈中数据，当 Goroutine 中运行的函数返回时，程序会跳转到 [`runtime.goexit`](https://draveness.me/golang/tree/runtime.goexit) 所在位置执行该函数：

```go
TEXT runtime·goexit(SB),NOSPLIT,$0-0
	CALL	runtime·goexit1(SB)

func goexit1() {
	mcall(goexit0)
}
```

经过一系列复杂的函数调用，我们最终在当前线程的 g0 的栈上调用 [`runtime.goexit0`](https://draveness.me/golang/tree/runtime.goexit0) 函数，该函数会将 Goroutine 转换会 `_Gdead` 状态、清理其中的字段、移除 Goroutine 和线程的关联并调用 [`runtime.gfput`](https://draveness.me/golang/tree/runtime.gfput) 重新加入处理器的 Goroutine 空闲列表 `gFree`：

```go
func goexit0(gp *g) {
	_g_ := getg()

	casgstatus(gp, _Grunning, _Gdead)
	gp.m = nil
	...
	gp.param = nil
	gp.labels = nil
	gp.timer = nil

	dropg()
	gfput(_g_.m.p.ptr(), gp)
	schedule()
}
```

在最后 [`runtime.goexit0`](https://draveness.me/golang/tree/runtime.goexit0) 会重新调用 [`runtime.schedule`](https://draveness.me/golang/tree/runtime.schedule) 触发新一轮的 Goroutine 调度，Go 语言中的运行时调度循环会从 [`runtime.schedule`](https://draveness.me/golang/tree/runtime.schedule) 开始，最终又回到 [`runtime.schedule`](https://draveness.me/golang/tree/runtime.schedule)，我们可以认为调度循环永远都不会返回。

![golang-scheduler-loop](https://img.draveness.me/2020-02-05-15808864354669-golang-scheduler-loop.png)

**图:调度循环**

这里介绍的是 Goroutine 正常执行并退出的逻辑，实际情况会复杂得多，多数情况下 Goroutine 在执行的过程中都会经历协作式或者抢占式调度，它会让出线程的使用权等待调度器的唤醒。



## 触发调度





##  线程管理





## 问题



## 参考链接

1.3.[Go 语言设计与实现](https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/)