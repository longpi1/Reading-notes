# Golang 调度器源码分析（二、调度循环、触发调度、线程管理）

> 注意当前go版本代码为1.23



## 介绍

关于Golang的协程调度器原理及GMP设计思想可以通过[Golang的协程调度器原理及GMP设计思想](https://github.com/longpi1/Reading-notes/blob/main/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/Golang%E7%9A%84%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E5%8F%8AGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3.md)进行了解，相关基础结构与启动以及创建源码可查看上一篇文章，这一篇文章主要介绍调度器的调度循环实现、触发调度的时机以及线程管理。



## 调度循环

```go
// schedule 执行一轮调度：寻找一个可运行的 goroutine 并执行它。
// 该函数永不返回。
func schedule() {
        // 获取当前 goroutine 的 M（机器，代表线程）
        mp := getg().m

///......忽略非核心代码

top:
        // 获取当前 M 绑定的 P（处理器，代表调度资源）
        pp := mp.p.ptr()
        // 重置 P 的抢占标志，表明当前不处于抢占状态
        pp.preempt = false

///......忽略非核心代码

        // 寻找一个可运行的 goroutine，可能会阻塞直到有工作可用
        // 返回值：
        // - gp: 可运行的 goroutine
        // - inheritTime: 是否继承时间片（用于某些特殊 goroutine，如 GC worker）
        // - tryWakeP: 是否需要唤醒一个空闲的 P
        gp, inheritTime, tryWakeP := findRunnable()

        // 如果 debug.dontfreezetheworld > 0 并且系统正在冻结（freezing），
        // 则需要避免调度新的 goroutine。
        // 这是为了避免干扰调度器状态，因此在 findRunnable 中没有调用 gcstopm。
        // 这里通过死锁（双重锁）来阻止调度，而不是在 findRunnable 中处理，
        // 以避免干扰 findRunnable 的循环逻辑。
        if debug.dontfreezetheworld > 0 && freezing.Load() {
                lock(&deadlock)
                lock(&deadlock) // 死锁，阻止进一步执行
        }

        // 当前 M 将要运行一个 goroutine，不再处于 spinning 状态。
        // 如果之前标记为 spinning，则需要重置 spinning 状态，
        // 并可能启动一个新的 spinning M（以确保有足够的活跃线程寻找工作）。
        if mp.spinning {
                resetspinning()
        }

        // 如果用户调度被禁用（sched.disable.user），并且当前 goroutine 不允许调度，
        // 则将该 goroutine 放入待运行队列，等待用户调度重新启用后再次尝试。
        if sched.disable.user && !schedEnabled(gp) {
                lock(&sched.lock) // 锁定调度器状态
                if schedEnabled(gp) {
                        // 在获取锁的过程中，用户调度可能已被重新启用
                        unlock(&sched.lock)
                } else {
                        // 将当前 goroutine 放入禁用调度的待运行队列
                        sched.disable.runnable.pushBack(gp)
                        sched.disable.n++ // 增加待运行 goroutine 计数
                        unlock(&sched.lock)
                        goto top // 跳转到调度循环开始处，重新寻找工作
                }
        }

        // 如果即将调度的是非普通 goroutine（例如 GC worker 或 trace reader），
        // 并且 tryWakeP 为 true，则需要唤醒一个空闲的 P 以处理额外的工作。
        if tryWakeP {
                wakep()
        }

        // 如果当前 goroutine 绑定了一个特定的 M（通过 lockOSThread），
        // 则需要将当前 P 移交给绑定的 M，然后阻塞等待一个新的 P。
        if gp.lockedm != 0 {
                startlockedm(gp) // 启动绑定的 M 并等待新的 P
                goto top         // 跳转到调度循环开始处，重新寻找工作
        }

        // 执行找到的 goroutine，inheritTime 表示是否继承时间片。
        // 该函数永不返回，当前 M 将继续执行该 goroutine。
        execute(gp, inheritTime)
}
```



## 触发调度





##  线程管理





## 问题



## 参考链接

1.3.[Go 语言设计与实现](https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/)