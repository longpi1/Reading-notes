# Golang Map源码分析（一、定义与实现原理）

> 注意当前go版本代码为1.23

## 一、定义

Go Map底层采用的是哈希查找表，并使用链表（拉链法）来解决哈希冲突的问题实现了哈希表

```go
// A header for a Go map.
type hmap struct {
        // Note: the format of the hmap is also encoded in cmd/compile/internal/reflectdata/reflect.go.
        // Make sure this stays in sync with the compiler's definition.

        // count: map 中实际存储的键值对数量。
        // 必须是 hmap 结构体的第一个字段，因为内置函数 len() 会直接读取该字段。
        count int

        // flags: 用于存储 map 的状态标志，例如是否正在进行迭代、是否正在进行等量扩容等。
        flags uint8

        // B: buckets 数组大小的以 2 为底的对数。
        // 例如，B=5 表示 buckets 数组的大小为 2^5 = 32。
        // map 最多可以存储 loadFactor * 2^B 个键值对，loadFactor 是负载因子，默认为 6.5。
        B uint8

        // noverflow: 溢出桶的大致数量。
        // 这是一个近似值，因为在并发访问 map 时，noverflow 的更新可能会有延迟。
        // 详细的更新机制可以参考 incrnoverflow 函数的实现。
        noverflow uint16

        // hash0: 哈希种子，用于随机化键的哈希值。
        // 在创建 map 时，会生成一个随机的 hash0 值，用于防止哈希碰撞攻击。
        hash0 uint32


        // buckets: 指向 buckets 数组的指针。 buckets 数组的大小为 2^B。
        // 如果 count 为 0，则 buckets 可能为 nil。
        // 每个 bucket 存储多个键值对，具体数量由 bucketCnt 常量决定，通常为 8。
        buckets unsafe.Pointer

        // oldbuckets: 指向旧 buckets 数组的指针。
        // 仅在 map 扩容时使用。旧 buckets 数组的大小是新 buckets 数组的一半。
        // 在渐进式扩容过程中，键值对会逐渐从 oldbuckets 迁移到 buckets。
        oldbuckets unsafe.Pointer

        // nevacuate: 渐进式扩容的进度计数器。
        // 表示已经完成迁移的 buckets 数量。
        // buckets 数组中索引小于 nevacuate 的 bucket 都已经迁移到了新的 buckets 数组。
        nevacuate uintptr


        // extra: 指向 mapextra 结构体的指针，其中包含溢出桶和其他一些字段。
        // 如果没有溢出桶，则 extra 可能为 nil。
    	// extra.overflow：保存溢出桶链表
		// extra.oldoverflow：保存旧溢出桶链表
		// extra.nextOverflow：下一个空闲溢出桶地址
        extra *mapextra
}
```

buckets 是一个指针，最终它指向的是一个结构体：

```go
// bmap 是Go语言中map的桶结构，每个`hmap`包含多个这样的桶。
type bmap struct {
    // tophash 通常包含这个桶中每个键的哈希值的高字节。
    // 如果 tophash[0] < minTopHash, 则 tophash[0]表示桶的迁移状态。
    tophash [abi.OldMapBucketCount]uint8

    // 接下来是 bucketCnt 个键，然后是 bucketCnt 个元素。
    // 注意：将所有的键打包在一起，然后是所有的元素，这样做相比于交替排列键和元素（键/元素/键/元素/...） 
    // 会使代码稍微复杂一些，但这样可以消除填充（padding），因为某些类型如 map[int64]int8 需要填充来对齐。
    // 在键和元素之后，是一个指向溢出桶的指针。
    
    // 注意：Go语言的源码中并未直接在这里展示键和元素的定义，
    // 实际上，键和元素是紧跟在 tophash 数组之后的内存区域里。
}
```

tophash 通常包含此 buckets 中每个键的哈希值的最高字节。 如果 tophash[0] < minTopHash，则 tophash[0] 是一个桶疏散状态。

但这只是表面(src/runtime/map_noswiss.go)的结构，map 在编译时即确定了 map 中 key、value 及桶的大小，因此在运行时仅仅通过指针操作就可以找到特定位置的元素。编译期动态地创建一个新的结构：

```go
type bmap struct {
    topbits  [8]uint8 // 顶层位图，用于快速判断 key 是否存在。每个 bit 对应 keys 数组中的一个元素，如果 bit 为 1，表示对应的 key 存在；如果 bit 为 0，表示对应的 key 不存在。
    keys     [8]keytype  // 键数组，存储 map 的键。最多可以存储 8 个键。
    values   [8]valuetype // 值数组，存储 map 的值。与 keys 数组一一对应，keys[i] 对应的值为 values[i]。
    pad      uintptr    // 填充字段，用于内存对齐。uintptr 的大小与指针大小相同，在 32 位系统上为 4 字节，在 64 位系统上为 8 字节。
    overflow uintptr    // 溢出指针，指向下一个 bmap。当当前 bmap 存储满了 8 个键值对时，会创建一个新的 bmap，并将 overflow 指针指向新的 bmap。这样就形成了一个 bmap 的链表，可以存储超过 8 个键值对。
}


// 更加详细的解释：

// 1. topbits:  这是一个长度为 8 的 uint8 数组，用作位图。每个 uint8 可以表示 8 个键的存在状态，因此总共可以表示 8 * 8 = 64 个键。但在 bmap 结构体中，只使用了前 8 个键的空间，由 keys 和 values 数组体现。topbits 的作用是快速判断某个 key 是否存在于当前的 bmap 中。例如，要检查 keys[3] 是否存在，只需检查 topbits[0] 的第 4 个 bit（从 0 开始计数）是否为 1。

// 2. keys 和 values: 这两个数组分别存储键和值。它们的大小都是 8，这意味着一个 bmap 最多可以存储 8 个键值对。keys 的类型是 keytype，values 的类型是 valuetype，这两个类型可以根据实际存储的数据类型进行定义。

// 3. pad:  这是一个填充字段，用于内存对齐。Go 语言的 runtime 会根据数据类型的对齐要求进行填充，以提高内存访问效率。  bmap 的大小必须是机器字长的倍数。在 64 位架构上，机器字长是 8 字节。由于 `topbits` (8 字节) + `keys` (8 * keytype 的大小) + `values` (8 * valuetype 的大小) 的总大小可能不是 8 的倍数，因此需要 `pad` 来进行填充，保证 `overflow` 字段的地址是对齐的。  `pad` 的大小会根据 `keytype` 和 `valuetype` 的大小自动调整。

// 4. overflow: 这是一个指向下一个 bmap 的指针。当一个 bmap 满了（存储了 8 个键值对），并且需要插入新的键值对时，Go runtime 会分配一个新的 bmap，并将当前 bmap 的 overflow 指针指向新的 bmap。  这形成了一个类似链表的结构，允许 map 存储超过 8 个键值对。 通过这种溢出机制，Go 的 map 可以动态增长以容纳任意数量的元素。


//  示例：假设 keytype 和 valuetype 都是 uint32

//  如果一个 bmap 存储了 3 个键值对： key1, key2, key3，对应的值分别是 value1, value2, value3. 那么：

//  * topbits[0] 的值可能是 0b00000111  (表示前三个 key 存在)
//  * keys[0] = key1; values[0] = value1
//  * keys[1] = key2; values[1] = value2
//  * keys[2] = key3; values[2] = value3
//  * keys[3] 到 keys[7] 的值是未定义的
//  * values[3] 到 values[7] 的值是未定义的
//  * pad 的值由编译器决定，确保内存对齐
//  * 如果后续还有新的键值对插入，并且当前 bmap 已经满了，那么 runtime 会分配一个新的 bmap，并将当前 bmap 的 overflow 指针指向新的 bmap。
```

