# Golang Map源码分析（一、定义与实现原理）

> 注意当前go版本代码为1.23

## 定义

Go Map底层采用的是哈希查找表，并使用链表（拉链法）来解决哈希冲突的问题实现了哈希表

```go
// A header for a Go map.
type hmap struct {
        // Note: the format of the hmap is also encoded in cmd/compile/internal/reflectdata/reflect.go.
        // Make sure this stays in sync with the compiler's definition.

        // count: map 中实际存储的键值对数量。
        // 必须是 hmap 结构体的第一个字段，因为内置函数 len() 会直接读取该字段。
        count int

        // flags: 用于存储 map 的状态标志，例如是否正在进行迭代、是否正在进行等量扩容等。
        flags uint8

        // B: buckets 数组大小的以 2 为底的对数。
        // 例如，B=5 表示 buckets 数组的大小为 2^5 = 32。
        // map 最多可以存储 loadFactor * 2^B 个键值对，loadFactor 是负载因子，默认为 6.5。
        B uint8

        // noverflow: 溢出桶的大致数量。
        // 这是一个近似值，因为在并发访问 map 时，noverflow 的更新可能会有延迟。
        // 详细的更新机制可以参考 incrnoverflow 函数的实现。
        noverflow uint16

        // hash0: 哈希种子，用于随机化键的哈希值。
        // 在创建 map 时，会生成一个随机的 hash0 值，用于防止哈希碰撞攻击。
        hash0 uint32


        // buckets: 指向 buckets 数组的指针。 buckets 数组的大小为 2^B。
        // 如果 count 为 0，则 buckets 可能为 nil。
        // 每个 bucket 存储多个键值对，具体数量由 bucketCnt 常量决定，通常为 8。
        buckets unsafe.Pointer

        // oldbuckets: 指向旧 buckets 数组的指针。
        // 仅在 map 扩容时使用。旧 buckets 数组的大小是新 buckets 数组的一半。
        // 在渐进式扩容过程中，键值对会逐渐从 oldbuckets 迁移到 buckets。
        oldbuckets unsafe.Pointer

        // nevacuate: 渐进式扩容的进度计数器。
        // 表示已经完成迁移的 buckets 数量。
        // buckets 数组中索引小于 nevacuate 的 bucket 都已经迁移到了新的 buckets 数组。
        nevacuate uintptr


        // extra: 指向 mapextra 结构体的指针，其中包含溢出桶和其他一些字段。
        // 如果没有溢出桶，则 extra 可能为 nil。
    	// extra.overflow：保存溢出桶链表
		// extra.oldoverflow：保存旧溢出桶链表
		// extra.nextOverflow：下一个空闲溢出桶地址
        extra *mapextra
}
```

buckets 是一个指针，最终它指向的是一个结构体：

```go
// bmap 是Go语言中map的桶结构，每个`hmap`包含多个这样的桶。
type bmap struct {
    // tophash 通常包含这个桶中每个键的哈希值的高字节。
    // 如果 tophash[0] < minTopHash, 则 tophash[0]表示桶的迁移状态。
    tophash [abi.OldMapBucketCount]uint8

    // 接下来是 bucketCnt 个键，然后是 bucketCnt 个元素。
    // 注意：将所有的键打包在一起，然后是所有的元素，这样做相比于交替排列键和元素（键/元素/键/元素/...） 
    // 会使代码稍微复杂一些，但这样可以消除填充（padding），因为某些类型如 map[int64]int8 需要填充来对齐。
    // 在键和元素之后，是一个指向溢出桶的指针。
    
    // 注意：Go语言的源码中并未直接在这里展示键和元素的定义，
    // 实际上，键和元素是紧跟在 tophash 数组之后的内存区域里。
}
```

tophash 通常包含此 buckets 中每个键的哈希值的最高字节。 如果 tophash[0] < minTopHash，则 tophash[0] 是一个桶疏散状态。

但这只是表面(src/runtime/map_noswiss.go)的结构，map 在编译时即确定了 map 中 key、value 及桶的大小，因此在运行时仅仅通过指针操作就可以找到特定位置的元素。编译期动态地创建一个新的结构：

```go
type bmap struct {
    // topbits 存储每个键的哈希值的高 8 位信息。
    // 当哈希表执行查找操作时，首先比较这些高位信息，
    // 以快速排除不匹配的键，从而减少后续的比较次数。
    // 数组长度为 8，意味着每个桶最多可以存储 8 个键值对。
    topbits  [8]uint8 // 顶层位图，用于快速判断 key 是否存在。每个 bit 对应 keys 数组中的一个元素，如果 bit 为 1，表示对应的 key 存在；如果 bit 为 0，表示对应的 key 不存在。
    keys     [8]keytype  // 键数组，存储 map 的键。最多可以存储 8 个键。
    values   [8]valuetype // 值数组，存储 map 的值。与 keys 数组一一对应，keys[i] 对应的值为 values[i]。
    pad      uintptr    // 填充字段，用于内存对齐。uintptr 的大小与指针大小相同，在 32 位系统上为 4 字节，在 64 位系统上为 8 字节。
    overflow uintptr    // 溢出指针，指向下一个 bmap。当当前 bmap 存储满了 8 个键值对时，会创建一个新的 bmap，并将 overflow 指针指向新的 bmap。这样就形成了一个 bmap 的链表，可以存储超过 8 个键值对。
}


// 更加详细的解释：
// 1. topbits:  这是一个长度为 8 的 uint8 数组，用作位图。每个 uint8 可以表示 8 个键的存在状态，因此总共可以表示 8 * 8 = 64 个键。但在 bmap 结构体中，只使用了前 8 个键的空间，由 keys 和 values 数组体现。topbits 的作用是快速判断某个 key 是否存在于当前的 bmap 中。例如，要检查 keys[3] 是否存在，只需检查 topbits[0] 的第 4 个 bit（从 0 开始计数）是否为 1。

// 2. keys 和 values: 这两个数组分别存储键和值。它们的大小都是 8，这意味着一个 bmap 最多可以存储 8 个键值对。keys 的类型是 keytype，values 的类型是 valuetype，这两个类型可以根据实际存储的数据类型进行定义。

// 3. pad:  这是一个填充字段，用于内存对齐。Go 语言的 runtime 会根据数据类型的对齐要求进行填充，以提高内存访问效率。  bmap 的大小必须是机器字长的倍数。在 64 位架构上，机器字长是 8 字节。由于 `topbits` (8 字节) + `keys` (8 * keytype 的大小) + `values` (8 * valuetype 的大小) 的总大小可能不是 8 的倍数，因此需要 `pad` 来进行填充，保证 `overflow` 字段的地址是对齐的。  `pad` 的大小会根据 `keytype` 和 `valuetype` 的大小自动调整。

// 4. overflow: 这是一个指向下一个 bmap 的指针。当一个 bmap 满了（存储了 8 个键值对），并且需要插入新的键值对时，Go runtime 会分配一个新的 bmap，并将当前 bmap 的 overflow 指针指向新的 bmap。  这形成了一个类似链表的结构，允许 map 存储超过 8 个键值对。 通过这种溢出机制，Go 的 map 可以动态增长以容纳任意数量的元素。


//  示例：假设 keytype 和 valuetype 都是 uint32

//  如果一个 bmap 存储了 3 个键值对： key1, key2, key3，对应的值分别是 value1, value2, value3. 那么：

//  * topbits[0] 的值可能是 0b00000111  (表示前三个 key 存在)
//  * keys[0] = key1; values[0] = value1
//  * keys[1] = key2; values[1] = value2
//  * keys[2] = key3; values[2] = value3
//  * keys[3] 到 keys[7] 的值是未定义的
//  * values[3] 到 values[7] 的值是未定义的
//  * pad 的值由编译器决定，确保内存对齐
//  * 如果后续还有新的键值对插入，并且当前 bmap 已经满了，那么 runtime 会分配一个新的 bmap，并将当前 bmap 的 overflow 指针指向新的 bmap。
```

`bmap` 就是我们常说的“桶”，桶里面会最多装 8 个 key，这些 key 之所以会落入同一个桶，是因为它们经过哈希计算后，哈希结果是“一类”的。在桶内，又会根据 key 计算出来的 hash 值的高 8 位来决定 key 到底落入桶内的哪个位置（一个桶内最多有8个位置）。

来一个整体的图：

![hashmap bmap](https://golang.design/go-questions/map/assets/0.png)

当 map 的 key 和 value 都不是指针，并且 size 都小于 128 字节的情况下，会把 bmap 标记为不含指针，这样可以避免 gc 时扫描整个 hmap。但是，我们看 bmap 其实有一个 overflow 的字段，是指针类型的，破坏了 bmap 不含指针的设想，这时会把 overflow 移动到 extra 字段来。

```go
type mapextra struct {
	// overflow[0] contains overflow buckets for hmap.buckets.
	// overflow[1] contains overflow buckets for hmap.oldbuckets.
	overflow [2]*[]*bmap

	// nextOverflow 包含空闲的 overflow bucket，这是预分配的 bucket
	nextOverflow *bmap
}
```

bmap 是存放 k-v 的地方，我们把视角拉近，仔细看 bmap 的内部组成。

![bmap struct](https://golang.design/go-questions/map/assets/1.png)

上图就是 bucket 的内存模型，`HOB Hash` 指的就是 top hash。 注意到 key 和 value 是各自放在一起的，并不是 `key/value/key/value/...` 这样的形式。源码里说明这样的好处是在某些情况下可以省略掉 padding 字段，节省内存空间。

例如，有这样一个类型的 map：

```go
map[int64]int8
```

如果按照 `key/value/key/value/...` 这样的模式存储，那在每一个 key/value 对之后都要额外 padding 7 个字节；而将所有的 key，value 分别绑定到一起，这种形式 `key/key/.../value/value/...`，则只需要在最后添加 padding。

每个 bucket 设计成最多只能放 8 个 key-value 对，如果有第 9 个 key-value 落入当前的 bucket，那就需要再构建一个 bucket ，通过 `overflow` 指针连接起来。



## 问题

### 1.go中slice 和 map 分别作为函数参数时有什么区别？

在 Go 中，slice 和 map 作为函数参数时，都以**引用类型**的方式传递。这意味着函数接收到的并非 slice 或 map 的副本，而是指向底层数据的指针。 因此，函数内部对 slice 或 map 的修改会影响到调用者传入的原始数据。 然而，它们之间仍然存在一些关键区别：

**1. 数据结构和修改方式的区别:**

- **Slice:** Slice 是一个动态数组的引用，由指向底层数组的指针、长度和容量组成。 当你在函数内部修改 slice 的*元素*时，修改的是底层数组，因此调用者也能看到这些变化。 然而，如果在函数内部对 slice 进行*切片操作*或*重新分配内存*（例如 `append` 超过容量，导致重新分配底层数组），则会创建一个新的底层数组，原 slice 指向的底层数组保持不变。 这时，调用者看到的原始 slice 不会受到影响。
- **Map:** Map 是一个哈希表的引用。 当你在函数内部修改 map 的*键值对*时，修改的是原始 map 的内容，调用者也能看到这些变化。 包括添加、修改或删除键值对。 你不需要担心像 slice 那样底层数组重新分配的问题。

**2. 内存分配的影响:**

- **Slice:** 如果函数内对 slice 进行 append 操作，并且导致 slice 的容量超过了当前底层数组的容量，Go 会分配一个新的、更大的底层数组，并将原数组的内容复制到新数组中。 这会带来一定的内存分配和复制开销。 如果频繁进行这样的操作，可能会影响性能。
- **Map:** Map 的扩容机制与 slice 类似，当 map 中的元素数量达到一定阈值时，Go 会重新分配内存并进行 rehash。 但这通常不会像 slice 的 append 操作那样频繁，因为 map 的初始容量和负载因子会影响扩容的频率。

**3. nil 值的行为:**

- **Slice:** 将 nil slice 作为参数传递给函数，在函数内部可以对其进行 append 操作，这会创建一个新的底层数组。 函数返回后，调用者将看到一个新的、非 nil 的 slice。
- **Map:** 将 nil map 作为参数传递给函数，在函数内部直接对其进行赋值或取值操作会导致运行时错误 (panic)。 必须先使用 `make` 函数初始化 map，然后才能进行操作。

```go
func modifySlice(s []int) {
    //s[0] = 100         // 修改底层数组，调用者可见
    s = append(s, 200) // append 超过容量，创建新的底层数组，调用者不可见
    s = s[2:]          // 切片操作，创建新的 slice，调用者不可见

}

func modifyMap(m map[string]int) {
    m["a"] = 100 // 修改原始 map，调用者可见
    m["b"] = 200 // 修改原始 map，调用者可见
}

func main() {
    slice := []int{1, 2, 3}
    modifySlice(slice)
    fmt.Println(slice) // 输出: [1 2 3]  (append 和切片操作对原始 slice 无效)

    myMap := make(map[string]int)
    modifyMap(myMap)
    fmt.Println(myMap) // 输出: map[a:100 b:200] (修改对原始 map 可见)
 }
```



## 参考链接

1.[Go 程序员面试笔试宝典](https://golang.design/go-questions)

2.《Go学习笔记》

3.[Go 语言设计与实现](https://draveness.me/golang)

4.