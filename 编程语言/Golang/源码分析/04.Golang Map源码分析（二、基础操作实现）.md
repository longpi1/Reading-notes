# Golang Map源码分析（二、基础操作实现）

> 注意当前go版本代码为1.23

```go
// A header for a Go map.
type hmap struct {
        // Note: the format of the hmap is also encoded in cmd/compile/internal/reflectdata/reflect.go.
        // Make sure this stays in sync with the compiler's definition.

        // count: map 中实际存储的键值对数量。
        // 必须是 hmap 结构体的第一个字段，因为内置函数 len() 会直接读取该字段。
        count int

        // flags: 用于存储 map 的状态标志，例如是否正在进行迭代、是否正在进行等量扩容等。
        flags uint8

        // B: buckets 数组大小的以 2 为底的对数。
        // 例如，B=5 表示 buckets 数组的大小为 2^5 = 32。
        // map 最多可以存储 loadFactor * 2^B 个键值对，loadFactor 是负载因子，默认为 6.5。
        B uint8

        // noverflow: 溢出桶的大致数量。
        // 这是一个近似值，因为在并发访问 map 时，noverflow 的更新可能会有延迟。
        // 详细的更新机制可以参考 incrnoverflow 函数的实现。
        noverflow uint16

        // hash0: 哈希种子，用于随机化键的哈希值。
        // 在创建 map 时，会生成一个随机的 hash0 值，用于防止哈希碰撞攻击。
        hash0 uint32


        // buckets: 指向 buckets 数组的指针。 buckets 数组的大小为 2^B。
        // 如果 count 为 0，则 buckets 可能为 nil。
        // 每个 bucket 存储多个键值对，具体数量由 bucketCnt 常量决定，通常为 8。
        buckets unsafe.Pointer

        // oldbuckets: 指向旧 buckets 数组的指针。
        // 仅在 map 扩容时使用。旧 buckets 数组的大小是新 buckets 数组的一半。
        // 在渐进式扩容过程中，键值对会逐渐从 oldbuckets 迁移到 buckets。
        oldbuckets unsafe.Pointer

        // nevacuate: 渐进式扩容的进度计数器。
        // 表示已经完成迁移的 buckets 数量。
        // buckets 数组中索引小于 nevacuate 的 bucket 都已经迁移到了新的 buckets 数组。
        nevacuate uintptr


        // extra: 指向 mapextra 结构体的指针，其中包含溢出桶和其他一些字段。
        // 如果没有溢出桶，则 extra 可能为 nil。
    	// extra.overflow：保存溢出桶链表
		// extra.oldoverflow：保存旧溢出桶链表
		// extra.nextOverflow：下一个空闲溢出桶地址
        extra *mapextra
}
```

上一篇文章我们介绍了map的结构与实现，接下来我们看看map的基础操作是如何实现的吧

## 基础操作

## 初始化

从语法层面上来说，创建 map 很简单：

```golang
mp := make(map[string]int)
// 指定长度
mp := make(map[string]int, 8)

mp := map[string]int{
	"1": 2,
	"3": 4,
	"5": 6,
}

// mp 为 nil，不能向其添加元素，会直接panic
var mp map[string]int
```

通过汇编语言可以看到，实际上底层调用的是 `makemap` 函数，主要做的工作就是初始化 `hmap` 结构体的各种字段，例如计算 B 的大小，设置哈希种子 hash0 等等。

```golang
// makemap 函数实现了 Go 语言中 `make(map[k]v, hint)` 创建 map 的操作。
// 如果编译器确定 map 或第一个桶可以在栈上创建，那么 h 和/或 bucket 可能不为 nil。
// 如果 h 不为 nil，则可以直接在 h 中创建 map。
// 如果 h.buckets 不为 nil，则指向的 bucket 可以用作第一个桶。
func makemap(t *maptype, hint int, h *hmap) *hmap {
	// 计算 hint 个元素所需的内存大小，并检查是否溢出或超过最大分配限制。
	mem, overflow := math.MulUintptr(uintptr(hint), t.Bucket.Size_)
	if overflow || mem > maxAlloc {
		hint = 0 // 如果溢出或超过限制，将 hint 设置为 0。
	}

	// 初始化 Hmap
	if h == nil {
		h = new(hmap) // 如果 h 为 nil，则创建一个新的 hmap。
	}
	h.hash0 = uint32(rand()) // 生成一个随机的 hash0 值。

	// 找到合适的 B 值，它决定了 map 可以容纳的元素数量。
	// 当 hint < 0 时，overLoadFactor 返回 false，因为 hint < bucketCnt。
	B := uint8(0)
	for overLoadFactor(hint, B) { // 循环直到找到合适的 B 值。
		B++
	}
	h.B = B // 将 B 值存储到 hmap 中。

	// 分配初始的哈希表
	// 如果 B == 0，buckets 字段会在后续 (mapassign) 中延迟分配。
	// 如果 hint 很大，将这块内存清零可能会花费一些时间。
	if h.B != 0 {
		var nextOverflow *bmap
		h.buckets, nextOverflow = makeBucketArray(t, h.B, nil) // 创建桶数组。
		if nextOverflow != nil {
			h.extra = new(mapextra)             // 如果有溢出桶，则创建 mapextra。
			h.extra.nextOverflow = nextOverflow // 设置 nextOverflow。
		}
	}

	return h // 返回创建的 hmap。
}




// makeBucketArray 函数初始化 map 桶的底层数组。
//
// 参数：
//   t: map的类型信息。
//   b: 桶数组的级别，用于计算桶的数量。桶的数量大致为 2^b。
//   dirtyalloc: 可选的预分配内存块，如果非空，则会重用该内存块。
// 返回值：
//   buckets: 指向新桶数组的指针。
//   nextOverflow: 指向下一个可用的溢出桶的指针，如果不需要溢出桶，则为 nil。
func makeBucketArray(t *maptype, b uint8, dirtyalloc unsafe.Pointer) (buckets unsafe.Pointer, nextOverflow *bmap) {
	// 计算桶的基本数量，即 2^b。
	base := bucketShift(b)

	// 初始化桶的数量为基本数量。
	nbuckets := base

	// 对于较小的 b 值，溢出桶不太可能出现。
	// 为了避免计算的开销，直接使用基本数量的桶。
	if b >= 4 {
		// 添加估计需要的溢出桶的数量，
		// 用于插入此 b 值对应的元素数量的中位数。
		// 这里使用 b-4 是一个经验值，用于估计溢出桶的数量。
		nbuckets += bucketShift(b - 4)

		// 计算桶数组的总大小（字节）。
		sz := t.Bucket.Size_ * nbuckets

		// 对桶数组的大小进行向上取整，以确保内存对齐。
		// !t.Bucket.Pointers() 用于判断桶是否包含指针。
		// 如果桶包含指针，则向上取整到指针大小的倍数；否则向上取整到 8 字节的倍数。
		up := roundupsize(sz, !t.Bucket.Pointers())

		// 如果向上取整后的值与原始值不同，则更新桶的数量。
		if up != sz {
			nbuckets = up / t.Bucket.Size_
		}
	}

	// 如果没有提供预分配的内存块，则分配一个新的内存块。
	if dirtyalloc == nil {
		buckets = newarray(t.Bucket, int(nbuckets))
	} else {
		// 重用预分配的内存块 dirtyalloc。
		// dirtyalloc 之前由 newarray(t.Bucket, int(nbuckets)) 生成，
		// 但可能不为空，因此需要清空。
		buckets = dirtyalloc

		// 计算桶数组的总大小（字节）。
		size := t.Bucket.Size_ * nbuckets

		// 根据桶是否包含指针，使用不同的清空函数。
		if t.Bucket.Pointers() {
			// 如果桶包含指针，则使用 memclrHasPointers 清空内存，
			// 并将指针置为 nil，避免潜在的内存问题。
			memclrHasPointers(buckets, size)
		} else {
			// 如果桶不包含指针，则使用 memclrNoHeapPointers 清空内存。
			memclrNoHeapPointers(buckets, size)
		}
	}

	// 如果预分配了溢出桶，则设置 nextOverflow 指针和溢出桶的链接。
	if base != nbuckets {
		// 我们预分配了一些溢出桶。
		// 为了尽量减少跟踪这些溢出桶的开销，
		// 我们使用以下约定：如果预分配的溢出桶的 overflow 指针为 nil，
		// 则可以通过递增指针获得更多可用的溢出桶。
		// 最后一个溢出桶需要一个安全的非 nil 指针；这里使用 buckets。

		// nextOverflow 指向第一个溢出桶。
		nextOverflow = (*bmap)(add(buckets, base*uintptr(t.BucketSize)))

		// last 指向最后一个溢出桶。
		last := (*bmap)(add(buckets, (nbuckets-1)*uintptr(t.BucketSize)))

		// 将最后一个溢出桶的 overflow 指针设置为指向 buckets，
		// 形成一个循环链表，方便后续分配溢出桶。
		last.setoverflow(t, (*bmap)(buckets))
	}

	// 返回桶数组指针和下一个可用的溢出桶指针。
	return buckets, nextOverflow
}
```

`hint` 和 `b`（在代码中为 `B`）的意义如下：

- **`hint` (int):** `hint` 参数表示 map 预期的元素个数。它作为创建 map 的初始容量的参考。`makemap` 函数会根据 `hint` 的值来确定初始桶的数量和大小，以尽量减少后续的扩容操作，提高性能。 需要注意的是，`hint` 只是一个建议值，Go 运行时并不保证最终创建的 map 的容量与 `hint` 完全一致。如果 `hint` 的值过大或者计算过程中发生溢出，`hint` 会被重置为 0。
- **`B` (uint8):** `B` 决定了 map 的桶数组的大小。桶数组的大小为 2 的 `B` 次方。`B` 值越大，桶数组越大，可以容纳的元素越多，但同时也会占用更多的内存。`B` 的值是通过 `overLoadFactor` 函数计算得出的，该函数会根据 `hint` 值和当前的 `B` 值判断是否需要增加 `B` 的值。`makemap` 函数会不断增加 `B` 的值，直到找到一个合适的 `B` 值，使得 map 能够容纳 `hint` 个元素，并且负载因子不会过高。

`makemap` 函数的目标是创建一个合适的哈希表，以存储用户指定数量的元素。为了实现这个目标，它需要确定两个关键参数：

1. **桶的数量：** 桶的数量越多，哈希冲突的概率就越小，但同时也会占用更多的内存。
2. **桶的大小：** 每个桶可以存储多个键值对。桶越大，可以存储的键值对越多，但查找效率会降低。

`hint` 参数用于指导 `makemap` 函数确定桶的数量。`makemap` 函数会根据 `hint` 的值计算出一个合适的 `B` 值，然后使用 2 的 `B` 次方作为桶的数量。

`overLoadFactor` 函数用于判断当前的 `B` 值是否足够大。如果 `hint` 除以 2 的 `B` 次方（即桶的数量）的结果大于一个预定的负载因子，则说明当前的 `B` 值不够大，需要继续增加。

通过这种方式，`makemap` 函数可以根据 `hint` 的值动态地调整桶的数量，以确保 map 具有合适的容量和性能。

总而言之，`hint` 提供了一个创建 map 的容量建议，而 `B` 是 `makemap` 函数根据 `hint` 计算得出的一个内部参数，它决定了 map 底层桶数组的大小，从而影响 map 的性能和内存占用。





## 问题



## 参考链接

1.[Go 程序员面试笔试宝典](https://golang.design/go-questions)

2.《Go学习笔记》

3.[Go 语言设计与实现](