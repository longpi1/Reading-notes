# Golang Map源码分析（二、基础操作实现）

> 注意当前go版本代码为1.23

```go
// A header for a Go map.
type hmap struct {
        // Note: the format of the hmap is also encoded in cmd/compile/internal/reflectdata/reflect.go.
        // Make sure this stays in sync with the compiler's definition.

        // count: map 中实际存储的键值对数量。
        // 必须是 hmap 结构体的第一个字段，因为内置函数 len() 会直接读取该字段。
        count int

        // flags: 用于存储 map 的状态标志，例如是否正在进行迭代、是否正在进行等量扩容等。
        flags uint8

        // B: buckets 数组大小的以 2 为底的对数。
        // 例如，B=5 表示 buckets 数组的大小为 2^5 = 32。
        // map 最多可以存储 loadFactor * 2^B 个键值对，loadFactor 是负载因子，默认为 6.5。
        B uint8

        // noverflow: 溢出桶的大致数量。
        // 这是一个近似值，因为在并发访问 map 时，noverflow 的更新可能会有延迟。
        // 详细的更新机制可以参考 incrnoverflow 函数的实现。
        noverflow uint16

        // hash0: 哈希种子，用于随机化键的哈希值。
        // 在创建 map 时，会生成一个随机的 hash0 值，用于防止哈希碰撞攻击。
        hash0 uint32


        // buckets: 指向 buckets 数组的指针。 buckets 数组的大小为 2^B。
        // 如果 count 为 0，则 buckets 可能为 nil。
        // 每个 bucket 存储多个键值对，具体数量由 bucketCnt 常量决定，通常为 8。
        buckets unsafe.Pointer

        // oldbuckets: 指向旧 buckets 数组的指针。
        // 仅在 map 扩容时使用。旧 buckets 数组的大小是新 buckets 数组的一半。
        // 在渐进式扩容过程中，键值对会逐渐从 oldbuckets 迁移到 buckets。
        oldbuckets unsafe.Pointer

        // nevacuate: 渐进式扩容的进度计数器。
        // 表示已经完成迁移的 buckets 数量。
        // buckets 数组中索引小于 nevacuate 的 bucket 都已经迁移到了新的 buckets 数组。
        nevacuate uintptr


        // extra: 指向 mapextra 结构体的指针，其中包含溢出桶和其他一些字段。
        // 如果没有溢出桶，则 extra 可能为 nil。
    	// extra.overflow：保存溢出桶链表
		// extra.oldoverflow：保存旧溢出桶链表
		// extra.nextOverflow：下一个空闲溢出桶地址
        extra *mapextra
}
```

上一篇文章我们介绍了map的结构与实现，接下来我们看看map的基础操作是如何实现的吧

## 基础操作

### 初始化

从语法层面上来说，创建 map 很简单：

```golang
mp := make(map[string]int)
// 指定长度
mp := make(map[string]int, 8)

mp := map[string]int{
	"1": 2,
	"3": 4,
	"5": 6,
}

// mp 为 nil，不能向其添加元素，会直接panic
var mp map[string]int
```

通过汇编语言可以看到，实际上底层调用的是 `makemap` 函数，主要做的工作就是初始化 `hmap` 结构体的各种字段，例如计算 B 的大小，设置哈希种子 hash0 等等。

```golang
// makemap 函数实现了 Go 语言中 `make(map[k]v, hint)` 创建 map 的操作。
// 如果编译器确定 map 或第一个桶可以在栈上创建，那么 h 和/或 bucket 可能不为 nil。
// 如果 h 不为 nil，则可以直接在 h 中创建 map。
// 如果 h.buckets 不为 nil，则指向的 bucket 可以用作第一个桶。
func makemap(t *maptype, hint int, h *hmap) *hmap {
	// 计算 hint 个元素所需的内存大小，并检查是否溢出或超过最大分配限制。
	mem, overflow := math.MulUintptr(uintptr(hint), t.Bucket.Size_)
	if overflow || mem > maxAlloc {
		hint = 0 // 如果溢出或超过限制，将 hint 设置为 0。
	}

	// 初始化 Hmap
	if h == nil {
		h = new(hmap) // 如果 h 为 nil，则创建一个新的 hmap。
	}
	h.hash0 = uint32(rand()) // 生成一个随机的 hash0 值。

	// 找到合适的 B 值，它决定了 map 可以容纳的元素数量。
	// 当 hint < 0 时，overLoadFactor 返回 false，因为 hint < bucketCnt。
	B := uint8(0)
	for overLoadFactor(hint, B) { // 循环直到找到合适的 B 值。
		B++
	}
	h.B = B // 将 B 值存储到 hmap 中。

	// 分配初始的哈希表
	// 如果 B == 0，buckets 字段会在后续 (mapassign) 中延迟分配。
	// 如果 hint 很大，将这块内存清零可能会花费一些时间。
	if h.B != 0 {
		var nextOverflow *bmap
		h.buckets, nextOverflow = makeBucketArray(t, h.B, nil) // 创建桶数组。
		if nextOverflow != nil {
			h.extra = new(mapextra)             // 如果有溢出桶，则创建 mapextra。
			h.extra.nextOverflow = nextOverflow // 设置 nextOverflow。
		}
	}

	return h // 返回创建的 hmap。
}




// makeBucketArray 函数初始化 map 桶的底层数组。
//
// 参数：
//   t: map的类型信息。
//   b: 桶数组的级别，用于计算桶的数量。桶的数量大致为 2^b。
//   dirtyalloc: 可选的预分配内存块，如果非空，则会重用该内存块。
// 返回值：
//   buckets: 指向新桶数组的指针。
//   nextOverflow: 指向下一个可用的溢出桶的指针，如果不需要溢出桶，则为 nil。
func makeBucketArray(t *maptype, b uint8, dirtyalloc unsafe.Pointer) (buckets unsafe.Pointer, nextOverflow *bmap) {
	// 计算桶的基本数量，即 2^b。
	base := bucketShift(b)

	// 初始化桶的数量为基本数量。
	nbuckets := base

	// 对于较小的 b 值，溢出桶不太可能出现。
	// 为了避免计算的开销，直接使用基本数量的桶。
	if b >= 4 {
		// 添加估计需要的溢出桶的数量，
		// 用于插入此 b 值对应的元素数量的中位数。
		// 这里使用 b-4 是一个经验值，用于估计溢出桶的数量。
		nbuckets += bucketShift(b - 4)

		// 计算桶数组的总大小（字节）。
		sz := t.Bucket.Size_ * nbuckets

		// 对桶数组的大小进行向上取整，以确保内存对齐。
		// !t.Bucket.Pointers() 用于判断桶是否包含指针。
		// 如果桶包含指针，则向上取整到指针大小的倍数；否则向上取整到 8 字节的倍数。
		up := roundupsize(sz, !t.Bucket.Pointers())

		// 如果向上取整后的值与原始值不同，则更新桶的数量。
		if up != sz {
			nbuckets = up / t.Bucket.Size_
		}
	}

	// 如果没有提供预分配的内存块，则分配一个新的内存块。
	if dirtyalloc == nil {
		buckets = newarray(t.Bucket, int(nbuckets))
	} else {
		// 重用预分配的内存块 dirtyalloc。
		// dirtyalloc 之前由 newarray(t.Bucket, int(nbuckets)) 生成，
		// 但可能不为空，因此需要清空。
		buckets = dirtyalloc

		// 计算桶数组的总大小（字节）。
		size := t.Bucket.Size_ * nbuckets

		// 根据桶是否包含指针，使用不同的清空函数。
		if t.Bucket.Pointers() {
			// 如果桶包含指针，则使用 memclrHasPointers 清空内存，
			// 并将指针置为 nil，避免潜在的内存问题。
			memclrHasPointers(buckets, size)
		} else {
			// 如果桶不包含指针，则使用 memclrNoHeapPointers 清空内存。
			memclrNoHeapPointers(buckets, size)
		}
	}

	// 如果预分配了溢出桶，则设置 nextOverflow 指针和溢出桶的链接。
	if base != nbuckets {
		// 我们预分配了一些溢出桶。
		// 为了尽量减少跟踪这些溢出桶的开销，
		// 我们使用以下约定：如果预分配的溢出桶的 overflow 指针为 nil，
		// 则可以通过递增指针获得更多可用的溢出桶。
		// 最后一个溢出桶需要一个安全的非 nil 指针；这里使用 buckets。

		// nextOverflow 指向第一个溢出桶。
		nextOverflow = (*bmap)(add(buckets, base*uintptr(t.BucketSize)))

		// last 指向最后一个溢出桶。
		last := (*bmap)(add(buckets, (nbuckets-1)*uintptr(t.BucketSize)))

		// 将最后一个溢出桶的 overflow 指针设置为指向 buckets，
		// 形成一个循环链表，方便后续分配溢出桶。
		last.setoverflow(t, (*bmap)(buckets))
	}

	// 返回桶数组指针和下一个可用的溢出桶指针。
	return buckets, nextOverflow
}
```

`hint` 和 `b`（在代码中为 `B`）的意义如下：

- **`hint` (int):** `hint` 参数表示 map 预期的元素个数。它作为创建 map 的初始容量的参考。`makemap` 函数会根据 `hint` 的值来确定初始桶的数量和大小，以尽量减少后续的扩容操作，提高性能。 需要注意的是，`hint` 只是一个建议值，Go 运行时并不保证最终创建的 map 的容量与 `hint` 完全一致。如果 `hint` 的值过大或者计算过程中发生溢出，`hint` 会被重置为 0。
- **`B` (uint8):** `B` 决定了 map 的桶数组的大小。桶数组的大小为 2 的 `B` 次方。`B` 值越大，桶数组越大，可以容纳的元素越多，但同时也会占用更多的内存。`B` 的值是通过 `overLoadFactor` 函数计算得出的，该函数会根据 `hint` 值和当前的 `B` 值判断是否需要增加 `B` 的值。`makemap` 函数会不断增加 `B` 的值，直到找到一个合适的 `B` 值，使得 map 能够容纳 `hint` 个元素，并且负载因子不会过高。

`makemap` 函数的目标是创建一个合适的哈希表，以存储用户指定数量的元素。为了实现这个目标，它需要确定两个关键参数：

1. **桶的数量：** 桶的数量越多，哈希冲突的概率就越小，但同时也会占用更多的内存。
2. **桶的大小：** 每个桶可以存储多个键值对。桶越大，可以存储的键值对越多，但查找效率会降低。

`hint` 参数用于指导 `makemap` 函数确定桶的数量。`makemap` 函数会根据 `hint` 的值计算出一个合适的 `B` 值，然后使用 2 的 `B` 次方作为桶的数量。

`overLoadFactor` 函数用于判断当前的 `B` 值是否足够大。如果 `hint` 除以 2 的 `B` 次方（即桶的数量）的结果大于一个预定的负载因子，则说明当前的 `B` 值不够大，需要继续增加。

通过这种方式，`makemap` 函数可以根据 `hint` 的值动态地调整桶的数量，以确保 map 具有合适的容量和性能。

总而言之，`hint` 提供了一个创建 map 的容量建议，而 `B` 是 `makemap` 函数根据 `hint` 计算得出的一个内部参数，它决定了 map 底层桶数组的大小，从而影响 map 的性能和内存占用。



### 读取

上一篇文章[《Golang Map源码分析（一、定义与实现原理）》](https://github.com/longpi1/Reading-notes/blob/main/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/03.Golang%20Map%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%E3%80%81%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%89.md)已经提到过key定位过程，其实就是get操作的主要逻辑，**总而言之， `map get` 的过程就是：前置检查 -> 计算哈希值 -> 定位桶 -> 遍历桶内条目 -> 比较 tophash 和 key -> 返回 value 指针 (或零值指针)。**这里再补充一下get的两种实现方式

```go
v     := m[key] // => v     := *mapaccess1(maptype, hash, &key)
v, ok := m[key] // => v, ok := mapaccess2(maptype, hash, &key)
```

赋值语句左侧接受参数的个数会决定使用的运行时方法：

- 当接受一个参数时，会使用 [`runtime.mapaccess1`](https://draveness.me/golang/tree/runtime.mapaccess1)，该函数仅会返回一个指向目标值的指针；
- 当接受两个参数时，会使用 [`runtime.mapaccess2`](https://draveness.me/golang/tree/runtime.mapaccess2)，除了返回目标值之外，它还会返回一个用于表示当前键对应的值是否存在的 `bool` 值：

另外，根据 key 的不同类型，编译器还会将查找、插入、删除的函数用更具体的函数替换，以优化效率：

| key 类型 | 查找                                                         |
| -------- | ------------------------------------------------------------ |
| uint32   | mapaccess1_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer |
| uint32   | mapaccess2_fast32(t *maptype, h *hmap, key uint32) (unsafe.Pointer, bool) |
| uint64   | mapaccess1_fast64(t *maptype, h *hmap, key uint64) unsafe.Pointer |
| uint64   | mapaccess2_fast64(t *maptype, h *hmap, key uint64) (unsafe.Pointer, bool) |
| string   | mapaccess1_faststr(t *maptype, h *hmap, ky string) unsafe.Pointer |
| string   | mapaccess2_faststr(t *maptype, h *hmap, ky string) (unsafe.Pointer, bool) |

这些函数的参数类型直接是具体的 uint32、unt64、string，在函数内部由于提前知晓了 key 的类型，所以内存布局是很清楚的，因此能节省很多操作，提高效率。



### 写入

通过汇编语言可以看到，向 map 中插入或者修改 key，最终调用的是 `mapassign` 函数。

实际上插入或修改 key 的语法是一样的，只不过前者操作的 key 在 map 中不存在，而后者操作的 key 存在 map 中。

mapassign 有一个系列的函数，根据 key 类型的不同，编译器会将其优化为相应的“快速函数”。

| key 类型 | 插入                                                         |
| -------- | ------------------------------------------------------------ |
| uint32   | mapassign_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer |
| uint64   | mapassign_fast64(t *maptype, h *hmap, key uint64) unsafe.Pointer |
| string   | mapassign_faststr(t *maptype, h *hmap, ky string) unsafe.Pointer |

我们只用研究最一般的赋值函数 `mapassign`。

整体流程与读取比较相似，可以将其分成几个部分依次分析，首先是函数会根据传入的键拿到对应的哈希和桶：

```go
// mapassign 函数是 Go 语言运行时中用于在 map 中赋值的关键函数。它处理了 map 的插入和更新操作，包括哈希计算、桶查找、冲突解决、扩容等重要步骤。
func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {
        // t: map 的类型信息，包含键和值的类型等。
        // h: 指向 hmap 结构的指针，hmap 是 map 的运行时表示。
        // key: 指向要赋值的键的指针。

        // 返回值：指向与键关联的值的指针。

        // .........前置检查
        
        // 计算键的哈希值
        hash := t.Hasher(key, uintptr(h.hash0))

       // 在计算哈希后设置写入标志，如果哈希计算过程中发生panic，不会错误地标记为写入
        h.flags ^= hashWriting

        // 如果桶数组为 nil，则初始化桶数组
        if h.buckets == nil {
                // 分配一个新的桶数组，初始容量为 1。
                h.buckets = newobject(t.Bucket) // newarray(t.Bucket, 1)
        }

again:
        // 计算键对应的 bucket
        bucket := hash & bucketMask(h.B)
        // 如果哈希表正在扩展，执行扩展操作
        if h.growing() {
                growWork(t, h, bucket)
        }
        // 获取 bucket 的指针
        b := (*bmap)(add(h.buckets, bucket*uintptr(t.BucketSize)))
        // 计算键哈希值的高 8 位（tophash）
        top := tophash(hash)


        // 初始化插入位置相关的变量,（inserti）指向 key 的 hash 值在 tophash 数组所处的位置，另一个(insertk)指向 cell 的位置（也就是 key 最终放置的地址）
        var inserti *uint8        // 指向要插入 tophash 的位置的指针
        var insertk unsafe.Pointer // 指向要插入键的位置的指针
        var elem unsafe.Pointer    // 指向要插入值的位置的指针

bucketloop:
        // 遍历桶中的槽位
        for {
                for i := uintptr(0); i < abi.OldMapBucketCount; i++ {
                        // 如果当前位置的 tophash 不匹配
                        if b.tophash[i] != top {
                                if isEmpty(b.tophash[i]) && inserti == nil {
                                        // 找到一个空位，准备插入
                                        inserti = &b.tophash[i]
                                        insertk = add(unsafe.Pointer(b), dataOffset+i*uintptr(t.KeySize))
                                        elem = add(unsafe.Pointer(b), dataOffset+abi.OldMapBucketCount*uintptr(t.KeySize)+i*uintptr(t.ValueSize))
                                }
                                if b.tophash[i] == emptyRest {
                                        break bucketloop  // 已经到bucket的末尾或下一个bucket
                                }
                                continue
                        }
                        // 匹配 tophash，检查键是否真正匹配
                        k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.KeySize))
                        if t.IndirectKey() {
                                k = *((*unsafe.Pointer)(k))
                        }
                        if !t.Key.Equal(key, k) {
                                continue
                        }
                        // 找到键，更新值
                        if t.NeedKeyUpdate() {
                                // runtime.typedmemmove 将键移动到对应的内存空间中并返回键对应值的地址 val
                                typedmemmove(t.Key, k, key)
                        }
                        elem = add(unsafe.Pointer(b), dataOffset+abi.OldMapBucketCount*uintptr(t.KeySize)+i*uintptr(t.ValueSize))
                        goto done
                }
                // 如果当前bucket已满，移动到overflow bucket
                ovf := b.overflow(t)
                if ovf == nil {
                        break
                }
                b = ovf
        }

        // 如果没有找到键，需要插入新键值对
        // 如果需要增长表，或溢出桶过多，开始增长
        if !h.growing() && (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) {
                hashGrow(t, h)
                goto again  // 表增长后，数据位置可能改变，重新尝试
        }

        if inserti == nil {
                // 如果所有bucket都满了，创建新的overflow bucket
                newb := h.newoverflow(t, b)
                inserti = &newb.tophash[0]
                insertk = add(unsafe.Pointer(newb), dataOffset)
                elem = add(insertk, abi.OldMapBucketCount*uintptr(t.KeySize))
        }

        // 在找到的位置存储新的键和元素
        if t.IndirectKey() {
                kmem := newobject(t.Key)
                *(*unsafe.Pointer)(insertk) = kmem
                insertk = kmem
        }
        if t.IndirectElem() {
                vmem := newobject(t.Elem)
                *(*unsafe.Pointer)(elem) = vmem
        }
        // runtime.typedmemmove 将键移动到对应的内存空间中并返回键对应值的地址 val
        typedmemmove(t.Key, insertk, key)
        *inserti = top
        h.count++

done:
        // 确保写入标志在操作结束时被正确清除
        if h.flags&hashWriting == 0 {
                fatal("concurrent map writes")
        }
        h.flags &^= hashWriting
        if t.IndirectElem() {
                elem = *((*unsafe.Pointer)(elem))
        }
        return elem
}
```

主要步骤总结：**0.前置检查 -> 1.计算哈希值 ->2. 定位桶 -> 3.遍历桶内条目 -> 4.1在桶中查找键，比较 tophash 和 key ，若找到则更新（更新后直接跳转步骤5），否则准备插入-> 4.2.插入新键值对，更新相关数据结构->5. 清除写入标志并返回值的指针**

重点介绍一下步骤4.1与4.2：

**4.1在桶中查找键**

- 遍历目标桶中的槽位，比较每个槽位的 `tophash`（哈希值的高8位）与目标 `tophash`。
- 如果 `tophash` 不匹配，且槽位为空，记录该位置作为潜在的插入点。
- 如果槽位为 `emptyRest`，表示已经到达桶的末尾，停止遍历。
- 如果 tophash匹配，进一步比较键是否相同：
  - 若键相同，执行更新操作，将新值写入对应位置，然后跳转到完成步骤。
- 如果当前桶遍历完仍未找到匹配的键，继续遍历溢出桶（overflow bucket）。

**4.2.插入新键值对，更新相关数据结构**

- 如果在桶中没有找到匹配的键，则准备插入新键值对。

- 在插入之前，检查是否需要对哈希表进行扩容：
  - 如果插入新键后负载因子超过阈值，或者溢出桶过多，触发哈希表的扩容操作（`hashGrow`），然后重新尝试插入操作。
- 如果找到了空位，直接使用该位置。如果没有空位，创建一个新的溢出桶。

- 将新键和值插入到找到的空位中：
  - 如果键或值是间接类型（`IndirectKey` 或 `IndirectElem`），则需要先分配内存。
- 更新 `tophash`，增加计数器 `count`，表示成功插入了一个新键值对。

> 需注意，哈希并不会在 runtime.mapassign这个运行时函数中将值拷贝到桶中，该函数只会返回内存地址，真正的赋值操作是在编译期间插入的：
>
> ```go
> 00018 (+5) CALL runtime.mapassign_fast64(SB)
> 00020 (5) MOVQ 24(SP), DI               ;; DI = &value
> 00026 (5) LEAQ go.string."88"(SB), AX   ;; AX = &"88"
> 00027 (5) MOVQ AX, (DI)                 ;; *DI = AX
> ```
>
> 其中 `24(SP)` 是该函数返回的值地址，我们通过 `LEAQ` 指令将字符串的地址存储到寄存器 `AX` 中，`MOVQ` 指令将字符串 `"88"` 存储到了目标地址上完成了这次哈希的写入。

### 扩容

上面介绍写入过程时因为篇幅我们省略了扩容操作，随着哈希表中元素的逐渐增加，哈希的性能会逐渐恶化，所以我们需要通过扩容更多的桶和更大的内存保证哈希的读写性能：

mapassign函数会在以下两种情况发生时触发哈希的扩容：

1. 装载因子已经超过 6.5；
2. 哈希使用了太多溢出桶；





### 删除











## 问题



## 参考链接

1.[Go 程序员面试笔试宝典](https://golang.design/go-questions)

2.《Go学习笔记》

3.[Go 语言设计与实现](