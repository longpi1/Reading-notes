# Golang 调度器源码分析 

> 注意当前go版本代码为1.23



## 介绍

关于Golang的协程调度器原理及GMP设计思想可以通过[Golang的协程调度器原理及GMP设计思想](https://github.com/longpi1/Reading-notes/blob/main/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/Golang%E7%9A%84%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E5%8F%8AGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3.md)进行了解。

![golang-scheduler](https://img.draveness.me/2020-02-05-15808864354595-golang-scheduler.png)

**Go 语言调度器三个重要组成部分 — 线程 M、Goroutine G 和处理器 P**

1. G — 表示 Goroutine，它是一个待执行的任务；
2. M — 表示操作系统的线程，它由操作系统的调度器调度和管理；
3. P — 表示处理器，它可以被看做运行在线程上的本地调度器；

### 数据结构

#### G

```go
type g struct {
    // 栈管理参数
    stack       stack   // 描述实际栈内存范围：[stack.lo, stack.hi)，偏移量对 runtime/cgo 可见
    stackguard0 uintptr // 栈增长检查的指针（通常为 stack.lo+StackGuard），可设为 StackPreempt 触发抢占
    stackguard1 uintptr // 系统栈（如g0、gsignal）的栈增长检查指针，其他协程设为 ~0 触发 morestackc 崩溃

    // 异常处理
    _panic *_panic // 当前最内层的 panic 结构（偏移量对 liblink 可见）
    _defer *_defer // 当前最内层的 defer 结构

    // 调度与上下文
    m         *m      // 当前绑定的 M（操作系统线程），偏移量对 arm liblink 可见
    sched     gobuf   // 协程切换时的寄存器上下文（SP、PC、BP 等）
    syscallsp uintptr // 若状态为 Gsyscall，保存 sched.sp 供 GC 使用
    syscallpc uintptr // 若状态为 Gsyscall，保存 sched.pc 供 GC 使用
    syscallbp uintptr // 若状态为 Gsyscall，保存 sched.bp 用于栈回溯
    stktopsp  uintptr // 栈顶期望的 SP 值，用于回溯检查

    // 通用参数传递
    param unsafe.Pointer // 多场景临时指针参数：
    // 1. Channel 操作唤醒时指向 sudog
    // 2. GC 辅助完成信号
    // 3. 调试调用传递参数（禁止闭包时）
    // 4. panic 恢复时保存 defer 状态

    // 状态与锁
    atomicstatus atomic.Uint32 // 协程原子状态（如 _Grunnable、_Gwaiting）
    stackLock    uint32        // 栈扫描/性能分析锁（未来可能合并到 atomicstatus）
    goid         uint64        // 协程唯一 ID
    schedlink    guintptr      // 调度链表指针，指向下一个待运行的 G
    waitsince    int64         // 协程进入阻塞的近似时间戳
    waitreason   waitReason    // 阻塞原因（若状态为 Gwaiting）

    // 抢占控制
    preempt       bool // 抢占标志（与 stackguard0=stackpreempt 冗余）
    preemptStop   bool // 抢占时是否转换为 _Gpreempted 状态（否则仅调度）
    preemptShrink bool // 是否在同步安全点收缩栈

    // 栈与内存管理
    asyncSafePoint   bool        // 是否停在异步安全点（栈帧无精确指针信息）
    paniconfault     bool        // 非法地址访问时 panic 而非崩溃
    gcscandone       bool        // 栈是否已扫描完成（受 _Gscan 状态保护）
    throwsplit       bool        // 禁止栈分裂
    activeStackChans bool        // 栈中有未锁定的 channel（栈复制需加锁）
    parkingOnChan    atomic.Bool // 是否即将在 channel 上停车（影响栈收缩）

    // GC 与追踪
    inMarkAssist  bool  // 是否在 GC 标记辅助阶段
    gcAssistBytes int64 // GC 辅助分配信用（正数免辅助，负数需扫描）

    // 协程控制
    coroexit   bool          // 协程退出参数（用于 coroswitch_m）
    lockedm    muintptr      // 锁定此 G 的 M（若在系统调用中）
    timer      *timer        // time.Sleep 缓存计时器
    selectDone atomic.Uint32 // select 操作是否已有结果

    // 其他
    // 忽略......
}
```



## 问题

1.goruntine与thread有什么区别？



2.关于Golang的协程调度器原理及GMP设计思想

可参考[Golang的协程调度器原理及GMP设计思想](https://github.com/longpi1/Reading-notes/blob/main/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/Golang%E7%9A%84%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E5%8F%8AGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3.md)



## 参考链接

1.3.[Go 语言设计与实现](https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/)