# Golang 调度器源码分析 

> 注意当前go版本代码为1.23



## 介绍

关于Golang的协程调度器原理及GMP设计思想可以通过[Golang的协程调度器原理及GMP设计思想](https://github.com/longpi1/Reading-notes/blob/main/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/Golang%E7%9A%84%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E5%8F%8AGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3.md)进行了解。

![golang-scheduler](https://img.draveness.me/2020-02-05-15808864354595-golang-scheduler.png)

**Go 语言调度器三个重要组成部分 — 线程 M、Goroutine G 和处理器 P**

1. G — 表示 Goroutine，它是一个待执行的任务；
2. M — 表示操作系统的线程，它由操作系统的调度器调度和管理；
3. P — 表示处理器，它可以被看做运行在线程上的本地调度器；

### 数据结构

#### G

```go
type g struct {
    // 栈管理参数
    stack       stack   // 描述实际栈内存范围：[stack.lo, stack.hi)，偏移量对 runtime/cgo 可见
    stackguard0 uintptr // 栈增长检查的指针（通常为 stack.lo+StackGuard），可设为 StackPreempt 触发抢占
    stackguard1 uintptr // 系统栈（如g0、gsignal）的栈增长检查指针，其他协程设为 ~0 触发 morestackc 崩溃

    // 异常处理
    _panic *_panic // 当前最内层的 panic 结构（偏移量对 liblink 可见）
    _defer *_defer // 当前最内层的 defer 结构

    // 调度与上下文
    m         *m      // 当前绑定的 M（操作系统线程），偏移量对 arm liblink 可见
    sched     gobuf   // 协程切换时的寄存器上下文（SP、PC、BP 等）
    syscallsp uintptr // 若状态为 Gsyscall，保存 sched.sp 供 GC 使用
    syscallpc uintptr // 若状态为 Gsyscall，保存 sched.pc 供 GC 使用
    syscallbp uintptr // 若状态为 Gsyscall，保存 sched.bp 用于栈回溯
    stktopsp  uintptr // 栈顶期望的 SP 值，用于回溯检查

    // 通用参数传递
    param unsafe.Pointer // 多场景临时指针参数：
    // 1. Channel 操作唤醒时指向 sudog
    // 2. GC 辅助完成信号
    // 3. 调试调用传递参数（禁止闭包时）
    // 4. panic 恢复时保存 defer 状态

    // 状态与锁
    atomicstatus atomic.Uint32 // 协程原子状态（如 _Grunnable、_Gwaiting）
    stackLock    uint32        // 栈扫描/性能分析锁（未来可能合并到 atomicstatus）
    goid         uint64        // 协程唯一 ID
    schedlink    guintptr      // 调度链表指针，指向下一个待运行的 G
    waitsince    int64         // 协程进入阻塞的近似时间戳
    waitreason   waitReason    // 阻塞原因（若状态为 Gwaiting）

    // 抢占控制
    preempt       bool // 抢占标志（与 stackguard0=stackpreempt 冗余）
    preemptStop   bool // 抢占时是否转换为 _Gpreempted 状态（否则仅调度）
    preemptShrink bool // 是否在同步安全点收缩栈

    // 栈与内存管理
    asyncSafePoint   bool        // 是否停在异步安全点（栈帧无精确指针信息）
    paniconfault     bool        // 非法地址访问时 panic 而非崩溃
    gcscandone       bool        // 栈是否已扫描完成（受 _Gscan 状态保护）
    throwsplit       bool        // 禁止栈分裂
    activeStackChans bool        // 栈中有未锁定的 channel（栈复制需加锁）
    parkingOnChan    atomic.Bool // 是否即将在 channel 上停车（影响栈收缩）

    // GC 与追踪
    inMarkAssist  bool  // 是否在 GC 标记辅助阶段
    gcAssistBytes int64 // GC 辅助分配信用（正数免辅助，负数需扫描）

    // 协程控制
    coroexit   bool          // 协程退出参数（用于 coroswitch_m）
    lockedm    muintptr      // 锁定此 G 的 M（若在系统调用中）
    timer      *timer        // time.Sleep 缓存计时器
    selectDone atomic.Uint32 // select 操作是否已有结果

    // 其他
    // 忽略......
}


type gobuf struct {
	// The offsets of sp, pc, and g are known to (hard-coded in) libmach.
	//
	// ctxt is unusual with respect to GC: it may be a
	// heap-allocated funcval, so GC needs to track it, but it
	// needs to be set and cleared from assembly, where it's
	// difficult to have write barriers. However, ctxt is really a
	// saved, live register, and we only ever exchange it between
	// the real register and the gobuf. Hence, we treat it as a
	// root during stack scanning, which means assembly that saves
	// and restores it doesn't need write barriers. It's still
	// typed as a pointer so that any other writes from Go get
	// write barriers.
	sp   uintptr
	pc   uintptr
	g    guintptr
	ctxt unsafe.Pointer
	ret  uintptr
	lr   uintptr
	bp   uintptr // for framepointer-enabled architectures
}
```

结构体 [`runtime.g`](https://draveness.me/golang/tree/runtime.g) 的 `atomicstatus` 字段存储了当前 Goroutine 的状态。除了几个已经不被使用的以及与 GC 相关的状态之外，Goroutine 可能处于以下 9 种状态：

| 状态          | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| `_Gidle`      | 刚刚被分配并且还没有被初始化                                 |
| `_Grunnable`  | 没有执行代码，没有栈的所有权，存储在运行队列中               |
| `_Grunning`   | 可以执行代码，拥有栈的所有权，被赋予了内核线程 M 和处理器 P  |
| `_Gsyscall`   | 正在执行系统调用，拥有栈的所有权，没有执行用户代码，被赋予了内核线程 M 但是不在运行队列上 |
| `_Gwaiting`   | 由于运行时而被阻塞，没有执行用户代码并且不在运行队列上，但是可能存在于 Channel 的等待队列上 |
| `_Gdead`      | 没有被使用，没有执行代码，可能有分配的栈                     |
| `_Gcopystack` | 栈正在被拷贝，没有执行代码，不在运行队列上                   |
| `_Gpreempted` | 由于抢占而被阻塞，没有执行用户代码并且不在运行队列上，等待唤醒 |
| `_Gscan`      | GC 正在扫描栈空间，没有执行代码，可以与其他状态同时存在      |

虽然 Goroutine 在运行时中定义的状态非常多而且复杂，但是我们可以将这些不同的状态聚合成三种：等待中、可运行、运行中，运行期间会在这三种状态来回切换：

- 等待中：Goroutine 正在等待某些条件满足，例如：系统调用结束等，包括 `_Gwaiting`、`_Gsyscall` 和 `_Gpreempted` 几个状态；
- 可运行：Goroutine 已经准备就绪，可以在线程运行，如果当前程序中有非常多的 Goroutine，每个 Goroutine 就可能会等待更多的时间，即 `_Grunnable`；
- 运行中：Goroutine 正在某个线程上运行，即 `_Grunning`；

**Goroutine 的常见状态迁移**

![golang-goroutine-state-transition](https://img.draveness.me/2020-02-05-15808864354615-golang-goroutine-state-transition.png)

上图展示了 Goroutine 状态迁移的常见路径，其中包括创建 Goroutine 到 Goroutine 被执行、触发系统调用或者抢占式调度器的状态迁移过程。



#### M

Go 语言并发模型中的 M 是操作系统线程。调度器最多可以创建 10000 个线程，但是其中大多数的线程都不会执行用户代码（可能陷入系统调用），最多只会有 `GOMAXPROCS` 个活跃线程能够正常运行。

在默认情况下，运行时会将 `GOMAXPROCS` 设置成当前机器的核数，我们也可以在程序中使用 [`runtime.GOMAXPROCS`](https://draveness.me/golang/tree/runtime.GOMAXPROCS) 来改变最大的活跃线程数。



## 问题

1.goruntine与thread有什么区别？



2.关于Golang的协程调度器原理及GMP设计思想

可参考[Golang的协程调度器原理及GMP设计思想](https://github.com/longpi1/Reading-notes/blob/main/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/Golang%E7%9A%84%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E5%8F%8AGMP%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3.md)



## 参考链接

1.3.[Go 语言设计与实现](https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/)