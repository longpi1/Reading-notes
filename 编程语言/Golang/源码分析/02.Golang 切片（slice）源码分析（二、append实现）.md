# Golang 切片（slice）源码分析（二、append实现）



## 问题

【引申1】

来看一个例子，来源于[这里](https://jiajunhuang.com/articles/2017_07_18-golang_slice.md.html)

```go
package main

import "fmt"

func main() {
    s := []int{5}
    s = append(s, 7)
    s = append(s, 9)
    x := append(s, 11)
    y := append(s, 12)
    fmt.Println(s, x, y)
}
```

| 代码               | 切片对应状态                                                 |
| ------------------ | ------------------------------------------------------------ |
| s := []int{5}      | s 只有一个元素，`[5]`                                        |
| s = append(s, 7)   | s 扩容，容量变为2，`[5, 7]`                                  |
| s = append(s, 9)   | s 扩容，容量变为4，`[5, 7, 9]`。注意，这时 s 长度是3，只有3个元素 |
| x := append(s, 11) | 由于 s 的底层数组仍然有空间，因此并不会扩容。这样，底层数组就变成了 `[5, 7, 9, 11]`。注意，此时 s = `[5, 7, 9]`，容量为4；x = `[5, 7, 9, 11]`，容量为4。这里 s 不变 |
| y := append(s, 12) | 这里还是在 s 元素的尾部追加元素，由于 s 的长度为3，容量为4，所以直接在底层数组索引为3的地方填上12。结果：s = `[5, 7, 9]`，y = `[5, 7, 9, 12]`，x = `[5, 7, 9, 12]`，x，y 的长度均为4，容量也均为4 |

所以最后程序的执行结果是：

```
[5 7 9] [5 7 9 12] [5 7 9 12]
```

这里要注意的是，append函数执行完后，返回的是一个全新的 slice，并且对传入的 slice 并不影响。



【引申2】

关于 `append`，来源于 [Golang Slice的扩容规则](https://jodezer.github.io/2017/05/golangSlice的扩容规则)。

```go
package main

import "fmt"

func main() {
	s := []int{1,2}
	s = append(s,4,5,6)
	fmt.Printf("len=%d, cap=%d",len(s),cap(s))
}
```

运行结果是：

```
len=5, cap=6
```

如果按网上各种文章中总结的那样：小于原 slice 长度小于 1024 的时候，容量每次增加 1 倍。添加元素 4 的时候，容量变为4；添加元素 5 的时候不变；添加元素 6 的时候容量增加 1 倍，变成 8。

那上面代码的运行结果应该是是：

```
`len=5, cap=8 `
```

这是错误的！我们来仔细看看，为什么会这样，再次搬出代码：

```go
// nextslicecap 计算下一个合适的切片容量。
// 该函数用于在切片需要扩容时，确定新的容量大小。
//  newLen: 切片的新长度（所需容量）。
//  oldCap: 切片的旧容量。
// 返回值: 新的切片容量。
func nextslicecap(newLen, oldCap int) int {
        newcap := oldCap // 将新的容量初始化为旧的容量

        doublecap := newcap + newcap // 计算旧容量的两倍

        // 如果新长度大于旧容量的两倍，则直接使用新长度作为新容量
        // 这是为了避免频繁的扩容操作，当所需长度远大于当前容量时，直接分配所需的空间
        if newLen > doublecap {
                return newLen
        }

        // 设置一个阈值，用于区分小切片和大切片
        const threshold = 256

        // 对于容量小于阈值的小切片，新容量直接设置为旧容量的两倍
        // 这是因为小切片的扩容成本相对较低
        if oldCap < threshold {
                return doublecap
        }

        // 对于容量大于等于阈值的大切片，采用更保守的扩容策略
        for {
                //  从2倍增长（小切片）过渡到1.25倍增长（大切片）。
                //  该公式在两者之间提供平滑的过渡。
                //  (newcap + 3*threshold) >> 2 等价于 (newcap + 3*threshold) / 4
                //  这使得新容量的增长比例在1.25到2之间，并随着切片容量的增大而逐渐接近1.25
                newcap += (newcap + 3*threshold) >> 2

                // 需要检查 `newcap >= newLen` 以及 `newcap` 是否溢出。
                // newLen 保证大于零，因此当 newcap 溢出时，`uint(newcap) > uint(newLen)` 不成立。
                // 这允许使用相同的比较来检查两者。
                // 使用uint类型进行比较是为了处理溢出情况。如果newcap溢出变成负数，转换为uint类型后会变成一个很大的正数，从而使得比较仍然有效。
                if uint(newcap) >= uint(newLen) {
                        break // 如果新容量足够大，则退出循环
                }
        }

        //  当 newcap 计算溢出时，将 newcap 设置为请求的容量。
        //  如果 newcap 小于等于 0，说明发生了溢出
        if newcap <= 0 {
                return newLen
        }
        return newcap // 返回计算出的新容量
}
```

这个函数的参数依次是 `元素的类型，老的 slice，新 slice 最小求的容量`。

例子中 `s` 原来只有 2 个元素，`len` 和 `cap` 都为 2，`append` 了三个元素后，长度变为 5，容量最小要变成 5，即调用 `growslice` 函数时，传入的第三个参数应该为 5。即 `cap=5`。而一方面，`doublecap` 是原 `slice`容量的 2 倍，等于 4。满足第一个 `if` 条件，所以 `newcap` 变成了 5。

接着调用了 `roundupsize` 函数，传入 40。（代码中ptrSize是指一个指针的大小，在64位机上是8）

我们再看内存对齐，搬出 `roundupsize` 函数的代码：

```go
// roundupsize 返回 mallocgc 为指定大小分配的内存块的大小，减去任何用于元数据的内联空间。
//  size: 请求分配的内存大小。
//  noscan:  如果为 true，则表示该内存块不需要垃圾回收扫描。
// 返回值: mallocgc 实际分配的内存块大小。
func roundupsize(size uintptr, noscan bool) (reqSize uintptr) {
        reqSize = size // 初始化请求大小

        // 处理小对象（小于等于 maxSmallSize-mallocHeaderSize）
        if reqSize <= maxSmallSize-mallocHeaderSize {
                // 小对象。
                // 如果需要垃圾回收扫描 (noscan 为 false) 并且大小大于 minSizeForMallocHeader，则添加 mallocHeaderSize 用于存储元数据。
                // heapBitsInSpan(reqSize) 用于检查对象是否足够小到可以存储在堆的位图中，如果可以，则不需要 mallocHeader。
                if !noscan && reqSize > minSizeForMallocHeader { // !noscan && !heapBitsInSpan(reqSize)
                        reqSize += mallocHeaderSize
                }

                // (reqSize - size) 为 mallocHeaderSize 或 0。如果添加了 mallocHeaderSize，我们需要从结果中减去它，因为 mallocgc 会再次添加它。
                // 这里是为了确保返回的大小是 mallocgc 实际分配的大小，而不是包含了头部之后的大小。

                // 进一步区分更小的对象和中等大小的对象，使用不同的查找表进行向上取整
                if reqSize <= smallSizeMax-8 {
                        // 对于非常小的对象，使用 size_to_class8 和 class_to_size 查找表进行向上取整，以 8 字节为粒度。
                        // divRoundUp(reqSize, smallSizeDiv) 计算 reqSize 在 smallSizeDiv 粒度下的向上取整值。
                        // class_to_size[...] 获取对应大小类的实际分配大小。
                        // 最后减去 (reqSize - size) 移除之前可能添加的 mallocHeaderSize。
                        return uintptr(class_to_size[size_to_class8[divRoundUp(reqSize, smallSizeDiv)]]) - (reqSize - size)
                }
                // 对于中等大小的对象，使用 size_to_class128 和 class_to_size 查找表进行向上取整，以 128 字节为粒度。
                return uintptr(class_to_size[size_to_class128[divRoundUp(reqSize-smallSizeMax, largeSizeDiv)]]) - (reqSize - size)
        }

        // 处理大对象（大于 maxSmallSize-mallocHeaderSize）
        // 大对象。将 reqSize 向上对齐到下一页。检查溢出。
        reqSize += pageSize - 1 // 将 reqSize 增加到下一页边界之前

        // 检查溢出。如果 reqSize 加上 pageSize - 1 后反而变小了，说明发生了溢出。
        if reqSize < size {
                return size // 返回原始大小，避免分配过大的内存
        }

        // 通过按位与运算将 reqSize 对齐到下一页边界。
        return reqSize &^ (pageSize - 1)
}
```

很明显，我们最终将返回这个式子的结果：

```
class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]] 
```

这是 `Go` 源码中有关内存分配的两个 `slice`。`class_to_size`通过 `spanClass`获取 `span`划分的 `object`大小。而 `size_to_class8` 表示通过 `size` 获取它的 `spanClass`。

```go
var size_to_class8 = [smallSizeMax/smallSizeDiv + 1]uint8{0, 1, 2, 3, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32}

var class_to_size = [_NumSizeClasses]uint16{0, 8, 16, 24, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 256, 288, 320, 352, 384, 416, 448, 480, 512, 576, 640, 704, 768, 896, 1024, 1152, 1280, 1408, 1536, 1792, 2048, 2304, 2688, 3072, 3200, 3456, 4096, 4864, 5376, 6144, 6528, 6784, 6912, 8192, 9472, 9728, 10240, 10880, 12288, 13568, 14336, 16384, 18432, 19072, 20480, 21760, 24576, 27264, 28672, 32768}
```

我们传进去的 `size` 等于 40。所以 `(size+smallSizeDiv-1)/smallSizeDiv = 5`；获取 `size_to_class8` 数组中索引为 `5` 的元素为 `5`；获取 `class_to_size` 中索引为 `5` 的元素为 `48`。

最终，新的 slice 的容量为 `6`：

```
newcap = int(capmem / ptrSize) // 6 
```

至于，上面的两个`魔法数组`的由来，就不展开了。

【引申3】 向一个nil的slice添加元素会发生什么？为什么？

其实 `nil slice` 或者 `empty slice` 都是可以通过调用 append 函数来获得底层数组的扩容。最终都是调用 `mallocgc` 来向 Go 的内存管理器申请到一块内存，然后再赋给原来的`nil slice` 或 `empty slice`，然后摇身一变，成为“真正”的 `slice` 了。