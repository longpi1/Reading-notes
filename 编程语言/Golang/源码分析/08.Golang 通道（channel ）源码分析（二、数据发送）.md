# Golang 通道（channel ）源码分析（二、数据发送）

> 注意当前go版本代码为1.23
>
> Channel 在运行时的内部表示是 [`runtime.hchan`](https://draveness.me/golang/tree/runtime.hchan)

当向 Channel 发送数据时，就需要使用 `ch <- i` 语句，编译器会将它解析成 `OSEND` 节点并在 [`cmd/compile/internal/gc.walkexpr`](https://draveness.me/golang/tree/cmd/compile/internal/gc.walkexpr) 中转换成 [`runtime.chansend1`](https://draveness.me/golang/tree/runtime.chansend1)：

## 数据发送

```go
// chansend 函数实现向 channel 发送数据的核心逻辑
// c: channel指针
// ep: 要发送的数据的指针
// block: 是否阻塞
// callerpc: 调用者的程序计数器
func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {
    // 。。。。。忽略前置检查逻辑
    
	// 情况1： 如果存在等待接收的 goroutine
    if sg := c.recvq.dequeue(); sg != nil {
       // 找到一个等待的接收者。我们将要发送的值直接传递给接收者，绕过通道缓冲区（如果有）。
       // send 函数负责将数据从发送者 ep 传递给接收者 sg，并在必要时唤醒接收者。
       // 第三个参数是一个函数，它将在数据传递完成后被调用，这里是解锁。
       send(c, sg, ep, func() { unlock(&c.lock) }, 3)
       return true
    }

    // 情况2： 如果通道缓冲区有空间
    if c.qcount < c.dataqsiz {
       // 空间在通道缓冲区中可用。将要发送的元素入队。
       // 获取下一个可用的缓冲区位置
       qp := chanbuf(c, c.sendx)
       // 如果开启了 race 竞争检测
       if raceenabled {
          // 通知竞争检测器，将要向通道缓冲区写入数据
          racenotify(c, c.sendx, nil)
       }
       // 将数据从 ep 复制到缓冲区
       typedmemmove(c.elemtype, qp, ep)
       // 发送索引加 1
       c.sendx++
       // 如果发送索引到达缓冲区末尾，则循环回到开头
       if c.sendx == c.dataqsiz {
          c.sendx = 0
       }
       c.qcount++
       unlock(&c.lock)
       return true
    }

    // 对于非阻塞发送，如果没有接收者且缓冲区已满，返回失败
    if !block {
       unlock(&c.lock)
       return false
    }

    // 情况3：代码执行到这里，说明是阻塞模式 (block == true) 且缓冲区已满，需要阻塞当前 goroutine 等待接收者

    // 获取当前 goroutine 的指针
    gp := getg()
    // 从 sudog 池中分配一个 sudog 结构体，用于表示当前 goroutine 在通道上的等待信息
    mysg := acquireSudog()
    // 初始化 sudog 的 releasetime 字段为 0，表示尚未记录阻塞时间
    mysg.releasetime = 0
    if t0 != 0 {
       mysg.releasetime = -1
    }

    // 在将要发送的数据指针分配给 mysg.elem 和将 mysg 加入到 gp.waiting 链表之间，不允许发生栈分裂。
    // 这是为了防止 copystack 在进行栈复制时，无法正确找到 mysg.elem 指向的数据。
    // 将要发送的数据的指针保存到 sudog 中
    mysg.elem = ep
    // 将 sudog 的 waitlink 指针置为 nil，表示当前 sudog 还没有加入到等待队列中
    mysg.waitlink = nil
    mysg.g = gp // 关联当前goroutine
    // 将 sudog 的 isSelect 字段设置为 false，表示当前操作不是 select 语句的一部分
    mysg.isSelect = false
    mysg.c = c        // 关联当前channel
    gp.waiting = mysg // 设置goroutine的等待对象
    // 将当前 goroutine 的 param 字段置为 nil，用于在唤醒时传递额外信息（这里不需要）
    gp.param = nil
    // 将 mysg 加入到通道的发送队列 c.sendq 中
    c.sendq.enqueue(mysg)

    //  parkingOnChan 字段设置为 true，通知其他goroutine，当前goroutine 即将因channel操作而阻塞
    // 这个时间窗口内不能进行栈收缩，因为G的状态正在改变
    gp.parkingOnChan.Store(true)

    // 调用 gopark 函数阻塞当前 goroutine
    // chanparkcommit 函数用于在真正阻塞前做一些提交操作，例如解锁等
    gopark(chanparkcommit, unsafe.Pointer(&c.lock), waitReasonChanSend, traceBlockChanSend, 2)

    // 确保待发送的值在接收者复制完成前不会被垃圾回收
    // sudog虽然有指向栈对象的指针，但不会被栈追踪器视为根对象
    KeepAlive(ep)

    // 被唤醒后的处理逻辑

    // 检查当前 goroutine 的 waiting 字段是否仍然指向 mysg，如果不一致，说明等待列表被破坏了
    if mysg != gp.waiting {
       throw("G waiting list is corrupted") // 等待列表损坏
    }
    // 将当前 goroutine 的 waiting 字段置为 nil，表示当前 goroutine 不再等待任何 sudog
    gp.waiting = nil
    // 将当前 goroutine 的 activeStackChans 字段设置为 false, 表示当前 goroutine 不在 channel 操作相关的栈上
    gp.activeStackChans = false
    // 检查 mysg 的 success 字段，如果为 false，则表示发送失败（例如通道被关闭）
    closed := !mysg.success
    gp.param = nil // 清空参数

    // 记录阻塞事件用于性能分析
    if mysg.releasetime > 0 {
       blockevent(mysg.releasetime-t0, 2)
    }

    // 清理sudog
    mysg.c = nil
    releaseSudog(mysg)

    // 处理channel关闭的情况
    if closed {
       if c.closed == 0 {
          throw("chansend: spurious wakeup") // 异常唤醒
       }
       panic(plainError("send on closed channel")) // channel已关闭则panic
    }
    return true // 发送成功
}
```

从上述代码可以知道，go通道发送主要流程总结如下：

**发送流程:**

1. **空 Channel 检查  &&   竞态检测   &&     (非阻塞)快速检测    &&    加锁    &&    Channel 关闭检查:**
2. **三种发送情况:**
   - **情况 1: 存在等待的接收者 (`c.recvq.dequeue() != nil`)**
     - 从接收队列 `c.recvq` 中取出一个等待的接收者 `sg`。
     - 调用 `send(c, sg, ep, func() { unlock(&c.lock) }, 3)` 直接将数据从发送者 `ep` 传递给接收者 `sg`，绕过缓冲区。
     - `send` 函数负责唤醒接收者 `sg`。
     - 发送成功，返回 `true`。
   - **情况 2: 缓冲区有空间 (`c.qcount < c.dataqsiz`)**
     - 计算下一个可用缓冲区位置 `qp`。
     - 如果启用了竞态检测，调用 `racenotify` 通知将要向缓冲区写入数据。
     - 使用 `typedmemmove` 将数据从 `ep` 复制到缓冲区 `qp`。
     - 更新发送索引 `c.sendx` 和缓冲区元素计数 `c.qcount`。
     - 释放锁 `c.lock`。
     - 发送成功，返回 `true`。
   - **情况 3: 缓冲区已满且为阻塞模式 (`block == true`)**
     - 获取当前 goroutine 的指针 `gp`。
     - 从 `sudog` 池中分配一个 `sudog` 结构体 `mysg`。
     - 初始化 `mysg` 的各个字段，包括要发送的数据指针 `ep`、当前 goroutine `gp`、当前 channel `c` 等。
     - 将 `mysg` 加入到 channel 的发送队列 `c.sendq` 中。
     - 设置 `gp.parkingOnChan` 为 `true`，表示 goroutine 即将因 channel 操作阻塞。
     - 调用 `gopark` 阻塞当前 goroutine，等待被唤醒。
     - `gopark` 会释放锁 `c.lock`。
     - 被唤醒后，检查 `gp.waiting` 是否仍然指向 `mysg`，确保等待列表的完整性。
     - 检查 `mysg.success` 字段，判断发送是否成功。
     - 清理 `mysg` 并释放。
     - 如果 `closed` 为 `true` (发送失败)，且 channel 未关闭，则抛出 "spurious wakeup" 异常；如果 channel









## 问题





## 参考链接

1.[Go 程序员面试笔试宝典](https://golang.design/go-questions)

2.《Go学习笔记》

3.[Go 语言设计与实现](https://draveness.me/golang)