# Golang 切片（slice）源码分析

## 一、定义

slice 的底层数据是数组，slice 是对数组的封装，它描述一个数组的片段。两者都可以通过下标来访问单个元素。

数组是定长的，长度定义好之后，不能再更改。在 Go 中，数组是不常见的，因为其长度是类型的一部分，限制了它的表达能力，比如 [3]int 和 [4]int 就是不同的类型。

而切片则非常灵活，它可以动态地扩容。切片的类型和长度无关。

数组就是一片连续的内存， slice 实际上是一个结构体，包含三个字段：长度、容量、底层数组。

```golang
type slice struct {
	array unsafe.Pointer
	len   int
	cap   int
}
```

数据结构如下：

![切片数据结构](https://golang.design/go-questions/slice/assets/0.png)

注意，底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice 的。



## 二、操作

### 2.1创建

[src/runtime/slice.go](https://github.com/golang/go/blob/master/src/runtime/slice.go)  主要逻辑就是基于容量申请内存。

```go
func makeslice(et *_type, len, cap int) unsafe.Pointer {
        // 计算切片所需的内存大小，cap 为切片容量，et.Size_ 为每个元素的大小
        // math.MulUintptr 执行无符号整数乘法，并返回结果和一个表示是否发生溢出的布尔值
        mem, overflow := math.MulUintptr(et.Size_, uintptr(cap))

        // 检查以下几种错误情况：
        // 1. overflow：容量计算时发生溢出
        // 2. mem > maxAlloc：所需的内存超过最大可分配内存
        // 3. len < 0：切片长度为负数
        // 4. len > cap：切片长度大于容量
        if overflow || mem > maxAlloc || len < 0 || len > cap {
                // 注意：当用户执行 make([]T, bignumber) 时，产生 "len out of range" 错误，而不是 "cap out of range" 错误。
                // 虽然 "cap out of range" 也是对的，但由于容量是隐式提供的，因此提示长度错误更清晰。
                // 参考：golang.org/issue/4085
                // 重新计算基于长度的内存大小，以便在容量溢出时提供更准确的错误信息（例如 len 也溢出）
                mem, overflow := math.MulUintptr(et.Size_, uintptr(len))
                // 再次检查溢出、内存超出限制以及长度为负数的情况
                if overflow || mem > maxAlloc || len < 0 {
                        panicmakeslicelen() // 长度错误，触发 panic
                }
                panicmakeslicecap() // 容量错误，触发 panic
        }

        // 调用 mallocgc 分配内存。
        // mallocgc 是 Go 运行时中的函数，用于分配内存并在垃圾回收器中注册该内存。
        // 参数：
        //   mem: 要分配的内存大小
        //   et: 切片元素的类型
        //   true: 指示分配的内存应该被清零
        return mallocgc(mem, et, true)
}
```



### 2.2扩容





### 2.3复制





## 三、测试



## 四、经典问题

【引申1】 [3]int 和 [4]int 是同一个类型吗？

不是。因为数组的长度是类型的一部分，这是与 slice 不同的一点。

【引申2】 下面的代码输出是什么？

说明：例子来自雨痕大佬《Go学习笔记》第四版，P43页。这里我会进行扩展，并会作图详细分析。

```golang
package main

import "fmt"

func main() {
	slice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
	s1 := slice[2:5]
	s2 := s1[2:6:7]

	s2 = append(s2, 100)
	s2 = append(s2, 200)

	s1[2] = 20

	fmt.Println(s1)
	fmt.Println(s2)
	fmt.Println(slice)
}
```

结果：

```golang
[2 3 20]
[4 5 6 7 100 200]
[0 1 2 3 20 5 6 7 100 9]
```

`s1` 从 `slice` 索引2（闭区间）到索引5（开区间，元素真正取到索引4），长度为3，容量默认到数组结尾，为8。 `s2` 从 `s1` 的索引2（闭区间）到索引6（开区间，元素真正取到索引5），容量到索引7（开区间，真正到索引6），为5。

![slice origin](https://golang.design/go-questions/slice/assets/1.png)

接着，向 `s2` 尾部追加一个元素 100：

| `1 ` | `s2 = append(s2, 100) ` |
| ---- | ----------------------- |
|      |                         |

`s2` 容量刚好够，直接追加。不过，这会修改原始数组对应位置的元素。这一改动，数组和 `s1` 都可以看得到。

![append 100](https://golang.design/go-questions/slice/assets/2.png)

再次向 `s2` 追加元素200：

| `1 ` | `s2 = append(s2, 200) ` |
| ---- | ----------------------- |
|      |                         |

这时，`s2` 的容量不够用，该扩容了。于是，`s2` 另起炉灶，将原来的元素复制新的位置，扩大自己的容量。并且为了应对未来可能的 `append` 带来的再一次扩容，`s2` 会在此次扩容的时候多留一些 `buffer`，将新的容量将扩大为原始容量的2倍，也就是10了。

![append 200](https://golang.design/go-questions/slice/assets/3.png)

最后，修改 `s1` 索引为2位置的元素：

| `1 ` | `s1[2] = 20 ` |
| ---- | ------------- |
|      |               |

这次只会影响原始数组相应位置的元素。它影响不到 `s2` 了，人家已经远走高飞了。

![s1[2]=20](https://golang.design/go-questions/slice/assets/4.png)

再提一点，打印 `s1` 的时候，只会打印出 `s1` 长度以内的元素。所以，只会打印出3个元素，虽然它的底层数组不止3个元素。



## 参考链接

1.[Go 程序员面试笔试宝典](https://golang.design/go-questions)

2.

