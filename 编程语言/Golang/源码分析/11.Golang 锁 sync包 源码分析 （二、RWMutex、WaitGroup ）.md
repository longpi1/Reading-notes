# Golang 锁 sync包 源码分析 （二、RWMutex、WaitGroup ）

> 注意当前go版本代码为1.23
>
> sync包 源码分析包主要介绍 Go 语言中常见的同步原语 [`sync.Mutex`](https://draveness.me/golang/tree/sync.Mutex)、[`sync.RWMutex`](https://draveness.me/golang/tree/sync.RWMutex)、[`sync.WaitGroup`](https://draveness.me/golang/tree/sync.WaitGroup)、[`sync.Once`](https://draveness.me/golang/tree/sync.Once) 和 [`sync.Cond`](https://draveness.me/golang/tree/sync.Cond) 以及扩展原语 [`golang/sync/errgroup.Group`](https://draveness.me/golang/tree/golang/sync/errgroup.Group)、[`golang/sync/semaphore.Weighted`](https://draveness.me/golang/tree/golang/sync/semaphore.Weighted) 和 [`golang/sync/singleflight.Group`](https://draveness.me/golang/tree/golang/sync/singleflight.Group) 的实现原理，同时也会涉及互斥锁、信号量等并发编程中的常见概念。

## 定义

### RWMutex 

读写互斥锁 [`sync.RWMutex`](https://draveness.me/golang/tree/sync.RWMutex) 是细粒度的互斥锁，它不限制资源的并发读，但是读写、写写操作无法并行执行。

|      |  读  |  写  |
| :--: | :--: | :--: |
|  读  |  Y   |  N   |
|  写  |  N   |  N   |

```go
type RWMutex struct {
    w           Mutex        // 复用互斥锁提供的能力；
    writerSem   uint32       // 用于写等待读
    readerSem   uint32       // 用于读等待写
    readerCount atomic.Int32 // 存储了当前正在执行的读操作数量；
    readerWait  atomic.Int32 // 表示当写操作被阻塞时等待的读操作个数
}

```

- 写操作使用 [`sync.RWMutex.Lock`](https://draveness.me/golang/tree/sync.RWMutex.Lock) 和 [`sync.RWMutex.Unlock`](https://draveness.me/golang/tree/sync.RWMutex.Unlock) 方法；
- 读操作使用 [`sync.RWMutex.RLock`](https://draveness.me/golang/tree/sync.RWMutex.RLock) 和 [`sync.RWMutex.RUnlock`](https://draveness.me/golang/tree/sync.RWMutex.RUnlock) 方法；



## RWMutex写锁

### 加锁

```go
func (rw *RWMutex) Lock() {
        if race.Enabled {
                _ = rw.w.state // 访问 rw.w 的状态，用于 race 检测
                race.Disable()  // 禁用 race 检测，因为我们即将进入临界区
        }
        // 首先，解决与其他写锁的竞争。
        rw.w.Lock() // 获取内部互斥锁 w，这会阻塞其他写操作。
        // 这确保了在任何时候只有一个写操作可以持有写锁。

        // 向读者宣告有一个正在等待的写者。
        // 通过从 readerCount 中减去 rwmuxMaxReaders 来实现。
        // rwmuxMaxReaders 是一个很大的值，使得 readerCount 变为负数或接近负数。
        // 这会通知正在尝试获取读锁的 goroutine，当前有写锁正在等待。
        r := rw.readerCount.Add(-rwmutexMaxReaders) + rwmutexMaxReaders
        // 此时，r 的值等于在添加操作之前 readerCount 的值。
        // 也就是说，r 代表了在写锁尝试获取时，活跃的读者的数量。

        // 等待活跃的读者完成。
        // 如果在写锁尝试获取时，仍然有活跃的读者 (r != 0)，
        // 并且我们递增 readerWait 计数器，并且返回值不为 0，
        // 那么当前写锁的 goroutine 需要等待。
        // readerWait 记录了需要等待的读者数量。
        if r != 0 && rw.readerWait.Add(r) != 0 {
                // runtime_SemacquireRWMutex 是一个 runtime 包提供的函数，
                // 用于阻塞当前的 goroutine，直到收到来自读者的信号。
                // &rw.writerSem 是用于写锁的信号量。
                // false 表示这不是一个可取消的等待。
                // 0 表示没有超时时间。
                runtime_SemacquireRWMutex(&rw.writerSem, false, 0)
        }
        if race.Enabled {
                race.Enable()              // 重新启用 race 检测
                race.Acquire(unsafe.Pointer(&rw.readerSem)) // 通知 race 检测器我们获得了读信号量
                race.Acquire(unsafe.Pointer(&rw.writerSem)) // 通知 race 检测器我们获得了写信号量
        }
}
```

1. 调用结构体持有的`sync.Mutex`结构体的`sync.Mutex.Lock`阻塞后续的写操作；
   - 因为互斥锁已经被获取，其他 Goroutine 在获取写锁时会进入自旋或者休眠；
2. 调用 [`sync/atomic.AddInt32`](https://draveness.me/golang/tree/sync/atomic.AddInt32) 函数阻塞后续的读操作：
3. 如果仍然有其他 Goroutine 持有互斥锁的读锁，该 Goroutine 会调用 [`runtime.sync_runtime_SemacquireMutex`](https://draveness.me/golang/tree/runtime.sync_runtime_SemacquireMutex) 进入休眠状态等待所有读锁所有者执行结束后释放 `writerSem` 信号量将当前协程唤醒；

### 解锁

[`sync.RWMutex.Unlock`](https://draveness.me/golang/tree/sync.RWMutex.Unlock)：

```go
func (rw *RWMutex) Unlock() {
        if race.Enabled {
                _ = rw.w.state                 // 访问 rw.w 的状态，用于 race 检测
                race.Release(unsafe.Pointer(&rw.readerSem)) // 通知 race 检测器我们释放了读信号量
                race.Disable()                 // 禁用 race 检测，因为我们即将离开临界区
        }

        // 向读者宣告没有活跃的写者。
        // 通过向 readerCount 中加上 rwmuxMaxReaders 来实现。
        // 这会将 readerCount 的值恢复到非负值，表示没有写锁持有。
        r := rw.readerCount.Add(rwmutexMaxReaders)
        // 此时，r 的值代表了在添加操作之后 readerCount 的值。

        // 如果 r 的值大于等于 rwmuxMaxReaders，
        // 说明在调用 Unlock 之前，readerCount 的值就已经是大于等于 0 的，
        // 这意味着没有写锁被持有，发生了对未锁定 RWMutex 的解锁操作。
        if r >= rwmutexMaxReaders {
                race.Enable() // 重新启用 race 检测
                fatal("sync: Unlock of unlocked RWMutex") // 抛出致命错误
        }
        // 解除阻塞被阻塞的读者，如果有的话。
        // 循环次数为之前等待的读者数量，即 r 的低位部分。
        // 因为 readerCount 可能很大，只有低位部分才是实际等待的读者数量。
        for i := 0; i < int(r); i++ {
                runtime_Semrelease(&rw.readerSem, false, 0)
        }

        // 释放写锁的互斥锁，允许其他写者获取写锁。
        rw.w.Unlock()

        // 如果启用了竞态检测，重新启用竞态检测。
        if race.Enabled {
                race.Enable()
        }

}
```

与加锁的过程正好相反，写锁的释放主要为以下几个执行：

1. 调用 [`sync/atomic.AddInt32`](https://draveness.me/golang/tree/sync/atomic.AddInt32) 函数将 `readerCount` 变回正数，释放读锁；
2. 通过 for 循环释放所有因为获取读锁而陷入等待的 Goroutine：
3. 调用 [`sync.Mutex.Unlock`](https://draveness.me/golang/tree/sync.Mutex.Unlock) 释放写锁；



## RWMutex读锁



### 加锁

```go
// RLock 获取读锁。
// 如果没有其他协程持有写锁，则允许当前协程持有读锁。
// 可以有多个协程同时持有读锁。
func (rw *RWMutex) RLock() {
        if race.Enabled {
                // 如果启用了竞态检测，则访问 rw.w.state，这会触发竞态检测器去检查是否有并发的写操作。
                _ = rw.w.state
                // 在尝试获取锁之前，禁用竞态检测，以避免竞态检测器自身导致的虚假报告。
                race.Disable()
        }
        // readerCount 原子地增加 1，表示当前有一个新的读者获取了读锁。
        // 如果增加后的值小于 0，则表示当前有写锁被持有或者有写锁在等待获取，
        // 此时读者需要等待。
        if rw.readerCount.Add(1) < 0 {
                // 有一个写锁正在等待或者已经被持有，当前读者需要等待。
                // runtime_SemacquireRWMutexR 是一个运行时函数，用于阻塞当前协程，
                // 直到 readerSem 信号量变为可用（即写锁被释放）。
                // 第二个参数 false 表示这不是一个可中断的等待。
                // 第三个参数 0 表示没有特定的超时时间。
                runtime_SemacquireRWMutexR(&rw.readerSem, false, 0)
        }
        if race.Enabled {
                // 在成功获取读锁后，重新启用竞态检测。
                race.Enable()
                // 通知竞态检测器，当前协程已经获取了 readerSem 信号量。
                race.Acquire(unsafe.Pointer(&rw.readerSem))
        }
}
```



### 解锁

```go
// RUnlock 释放一个 [RWMutex.RLock] 调用持有的读锁；
// 它不会影响其他同时持有读锁的协程。
// 如果在调用 RUnlock 时 rw 没有被读锁定，则会发生运行时错误。
func (rw *RWMutex) RUnlock() {
        if race.Enabled {
                // 如果启用了竞态检测，则访问 rw.w.state，这会触发竞态检测器去检查是否有并发的写操作。
                _ = rw.w.state
                // 通知竞态检测器，当前协程正在释放 writerSem 信号量。
                // ReleaseMerge 表示这是一个读锁释放，可能会导致等待的写锁被唤醒。
                race.ReleaseMerge(unsafe.Pointer(&rw.writerSem))
                // 在执行解锁操作期间，禁用竞态检测。
                race.Disable()
        }
        // 减少 readerCount 的值，表示当前有一个读锁被释放。
        // 如果返回值小于 0，说明当前有写锁在等待，需要进入慢路径处理。
        if r := rw.readerCount.Add(-1); r < 0 {
                // 外联的慢路径解锁逻辑，目的是让快速路径能够被内联优化。
                rw.rUnlockSlow(r)
        }
        if race.Enabled {
                // 在解锁操作完成后，重新启用竞态检测。
                race.Enable()
        }
}

// rUnlockSlow 是 RUnlock 的慢路径实现。
// 当 readerCount 变为负数时调用，表示可能存在错误或者有写锁在等待。
func (rw *RWMutex) rUnlockSlow(r int32) {
        // 如果 r+1 == 0 或 r+1 == -rwmutexMaxReaders，说明 RWMutex 没有被读锁锁定。
        // 这是一个运行时错误，会触发 fatal 错误。
        if r+1 == 0 || r+1 == -rwmutexMaxReaders {
                race.Enable() // 重新启用竞态检测
                fatal("sync: RUnlock of unlocked RWMutex") // 触发 fatal 错误
        }

        // 减少 readerWait 的值，表示当前有一个读锁被释放。
        // 如果 readerWait 的值变为 0，说明所有读锁都已释放，可以唤醒等待的写锁。
        if rw.readerWait.Add(-1) == 0 {
                // 最后一个读锁释放，唤醒等待的写锁。
                // runtime_Semrelease 是一个底层函数，用于唤醒等待的写锁。
                runtime_Semrelease(&rw.writerSem, false, 1)
        }
}
```



## 

## WaitGroup 



## 总结

- 





## 参考链接

1.3.[Go 语言设计与实现](https://draveness.me/golang)