# go GC时GMP是如何运行的

### 一、背景：GMP 模型与 GC 的目标

- **GMP 模型**：
  - **G (Goroutine)**：用户态的、轻量级的协程。
  - **P (Processor)**：一个逻辑处理器，是 G 和 M 之间的中间层。P 的数量默认等于 CPU 核心数（`GOMAXPROCS`）。**每个 P 都有一个自己的本地可运行 G 队列（Local Run Queue, LRQ）**。
  - **M (Machine)**：操作系统的线程。M 必须绑定一个 P 才能执行 G。
- **Go GC 的目标**：
  - **低延迟**：GC 导致的程序暂停时间（STW）要尽可能地短，最好在毫秒甚至亚毫秒级别。
  - **高吞吐**：GC 本身不能过多地占用 CPU 资源，影响程序的正常运行。
  - **并发执行**：GC 的大部分工作应该与用户的 Goroutine 并行执行。

为了实现这些目标，Go 的 GC 深度地与 GMP 调度器进行了集成。

------

### 二、GC 周期中的 GMP 运行状态

Go 的并发三色标记-清除 GC 周期可以大致分为以下几个阶段。我们会重点关注在每个阶段，G、M、P 都在做什么。

#### 阶段 1：GC 触发 (GC Triggering)

- **触发时机**：由 Go 运行时的步调算法（Pacing Algorithm）决定。简单来说，当程序新分配的堆内存达到一定阈值时（该阈值与上次 GC 后的堆大小和 `GOGC` 变量有关），就会触发一轮新的 GC。
- GMP 状态：
  - 此时，所有的 G、M、P 都在**正常运行**用户的业务代码。
  - 触发 GC 只是一个内部状态的改变，准备进入下一个阶段。

#### 阶段 2：标记准备 (Mark Setup) - **需要 STW**

- **目标**：开启“写屏障（Write Barrier）”，并准备开始标记工作。
- **STW (Stop The World)**：这是 GC 周期中的**第一个、非常短暂的 STW**。
- GMP 状态：
  - **调度器**会向所有的 P 发送一个信号，要求它们停止执行用户 G。
  - 正在运行的 M 会在安全的点（如函数调用、循环边界）停下来，将自己与 P 解绑。
  - 所有 P 的状态都变为 `_Pgcstop`。
  - 此时，**没有用户 Goroutine 在运行**。
  - **只有一个 G**（通常是在触发 GC 的那个 G 所在的 M 上）会执行标记准备工作。
  - 工作内容：
    1. **开启写屏障**：这是关键！写屏障是一个编译器插入的额外代码，它会“监控”程序在 GC 期间的所有指针写入操作。如果一个黑色对象指向了一个白色对象（违反了三色不变性），写屏障会拦截这次写入，并将白色对象重新标记为灰色，以防被错误地回收。
    2. 将根对象（全局变量、每个 G 栈上的变量）扫描出来，放入工作队列。
- **STW 结束**：准备工作完成后，STW 结束，用户 Goroutine 恢复运行。这个 STW 通常**非常快**（几十微秒级别）。

#### 阶段 3：并发标记 (Concurrent Marking) - **并行阶段**

- **目标**：找出所有存活的对象。这是 GC 中**最耗时**的阶段，但它是并发的。
- GMP 状态：
  - **用户 Goroutine 和 GC Goroutine 并行运行**。
  - Go 运行时会启动一定数量的**后台标记工作者（Background Mark Workers）**，这些是专门用于执行 GC 标记任务的 G。
  - 这些 GC 相关的 G 也会被 GMP 调度器像普通 G 一样调度到 P 和 M 上执行。
  - **GC 会“偷”一部分 CPU**：通常，GC 会占用 **25%** 的 CPU 资源。这意味着，如果有 `GOMAXPROCS` 个 P，那么大约会有 `GOMAXPROCS * 0.25` 个 P 会被专门用于运行 GC 的 G。
  - **Mutator Assist (辅助标记)**：如果用户的 Goroutine（被称为 Mutator）分配内存的速度**太快**，超过了后台标记的速度，那么这个正在分配内存的 G 会被**暂停**，并被**“抓壮丁”**去帮助 GC 完成一部分标记工作，直到 GC 进度追上来。这是 Go GC 防止程序“跑得比 GC 快”而导致 OOM 的重要机制。
  - **写屏障**：在此阶段，写屏障持续生效，保证了并发标记的正确性。

#### 阶段 4：标记终止 (Mark Termination) - **需要 STW**

- **目标**：完成所有标记工作，并关闭写屏障。
- **STW (Stop The World)**：这是 GC 周期中的**第二个 STW**。
- GMP 状态：
  - 再次暂停所有用户 Goroutine。
  - **只有一个 G** 会执行最后的标记工作，例如处理那些在并发标记期间被写屏障标记为灰色的对象，确保没有遗漏。
  - **关闭写屏障**。
- **STW 结束**：用户 Goroutine 恢复运行。这个 STW 的时间比第一个稍长，但也通常在几十到几百微秒之间。

#### 阶段 5：并发清扫 (Concurrent Sweeping) - **并行阶段**

- **目标**：回收未被标记的“垃圾”对象。
- GMP 状态：
  - **用户 Goroutine 和 GC 清扫操作并行运行**。
  - 清扫操作**不是**由专门的后台 Goroutine 完成的。
  - **“即用即扫” (Sweep on Allocation)**：当一个用户的 Goroutine 需要分配新内存时，它会先检查所需大小的空闲列表。如果找不到合适的内存块，它就会触发**清扫**操作，清理出一部分垃圾内存块，然后再进行分配。
  - **后台清扫**：同时，也会有一个后台任务在系统空闲时，慢慢地、逐步地完成整个堆的清扫工作。
- **优点**：这种方式将清扫的成本**分摊**到了每次内存分配中，避免了长时间的、集中的清扫暂停。

### 总结与图示

**一个简化的流程图：**

```
+------------------+      +-----------------+      +-----------------------+      +-------------------+      +-------------------+
|   用户 G 运行    |----->|   Mark Setup    |----->|   Concurrent Marking  |----->| Mark Termination  |----->| Concurrent Sweeping|
| (Normal GMP)     |      |   (STW)         |      | (Parallel with user G)|      |   (STW)           |      | (Parallel with user G)|
+------------------+      +-----------------+      +-----------------------+      +-------------------+      +-------------------+
        ^                                                                                                           |
        |____________________________________________(Allocation triggers new GC)______________________________________|
```

**GMP 在 GC 期间的关键行为**：

1. **短暂暂停 (STW)**：在两个极短的 STW 阶段（标记准备、标记终止），所有 P 都会停止执行用户 G，整个世界静止。
2. 并发标记：
   - GC 会启动专门的**标记 G**，这些 G 会和用户 G 一样，被调度器分配到 P 上运行，**抢占大约 25% 的 CPU 资源**。
   - 如果用户 G 分配内存过快，它会被暂停，**转而去辅助 GC**，这是一种动态的负载均衡。
3. 并发清扫：
   - 清扫工作被**嵌入**到了用户 G 的内存分配路径中。当用户 G 需要内存时，它可能会**顺便**做一些清扫工作。

通过这种深度融合的设计，Go 实现了 GC 过程对应用程序的“干扰”最小化。GC 不再是一个独立的、需要长时间暂停程序的“大事件”，而是变成了一个与程序执行**高度并发、协同工作**的、平滑的后台过程。这就是 Go GC 低延迟奥秘的核心所在。